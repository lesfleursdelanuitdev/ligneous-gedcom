
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>types: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/date.go (71.7%)</option>
				
				<option value="file1">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/date_node.go (40.0%)</option>
				
				<option value="file2">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/date_range.go (50.7%)</option>
				
				<option value="file3">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/duration.go (78.3%)</option>
				
				<option value="file4">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/error.go (100.0%)</option>
				
				<option value="file5">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/errors.go (0.0%)</option>
				
				<option value="file6">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/event.go (44.4%)</option>
				
				<option value="file7">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/event_node.go (0.0%)</option>
				
				<option value="file8">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/event_parser.go (63.8%)</option>
				
				<option value="file9">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/event_type.go (37.5%)</option>
				
				<option value="file10">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/family_record.go (22.0%)</option>
				
				<option value="file11">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/header_record.go (100.0%)</option>
				
				<option value="file12">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/individual_record.go (23.7%)</option>
				
				<option value="file13">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/line.go (93.3%)</option>
				
				<option value="file14">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/multimedia_record.go (100.0%)</option>
				
				<option value="file15">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/name.go (85.6%)</option>
				
				<option value="file16">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/name_node.go (47.1%)</option>
				
				<option value="file17">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/note_record.go (100.0%)</option>
				
				<option value="file18">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/place.go (74.1%)</option>
				
				<option value="file19">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/place_node.go (59.5%)</option>
				
				<option value="file20">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/record.go (95.5%)</option>
				
				<option value="file21">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/record_factory.go (100.0%)</option>
				
				<option value="file22">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/record_helpers.go (100.0%)</option>
				
				<option value="file23">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/repository_record.go (100.0%)</option>
				
				<option value="file24">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/source_record.go (100.0%)</option>
				
				<option value="file25">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/submitter_record.go (100.0%)</option>
				
				<option value="file26">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/testhelpers.go (0.0%)</option>
				
				<option value="file27">github.com/lesfleursdelanuitdev/ligneous-gedcom/types/tree.go (87.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package types

import (
        "fmt"
        "math"
        "regexp"
        "strconv"
        "strings"
        "time"
)

// DateType represents the type of a GEDCOM date.
type DateType string

const (
        DateTypeExact   DateType = "EXACT"
        DateTypeAbout   DateType = "ABOUT"
        DateTypeBefore  DateType = "BEFORE"
        DateTypeAfter   DateType = "AFTER"
        DateTypeBetween DateType = "BETWEEN"
        DateTypeFrom    DateType = "FROM"
        DateTypeTo      DateType = "TO"
        DateTypeFromTo  DateType = "FROM_TO"
        DateTypeUnknown DateType = "UNKNOWN"
)

// DateConstraint describes if a date is constrained by a particular range.
// This is similar to DateType but with different semantics for comparison operations.
type DateConstraint int

const (
        // DateConstraintExact - There is no constraint. The date is at the value specified.
        DateConstraintExact DateConstraint = iota

        // DateConstraintAbout - The date is approximate. There is no defined error margin
        // but it is usually proportional to how precise the date is.
        DateConstraintAbout

        // DateConstraintBefore - The real date is before the specified date value.
        DateConstraintBefore

        // DateConstraintAfter - The real date is after the specified date value.
        DateConstraintAfter
)

// DefaultMaxYearsForSimilarity is a sensible default for the Similarity function.
// Dates that are further apart than this value will return 0.0 similarity.
const DefaultMaxYearsForSimilarity = float64(3)

// Date words constants for parsing (case-insensitive)
const (
        DateWordsBetween = "Bet.|bet|between|from"
        DateWordsAnd     = "and|to|-"
        DateWordsAbout   = "Abt.|abt|about|c.|ca|ca.|cca|cca.|circa"
        DateWordsAfter   = "Aft.|aft|after"
        DateWordsBefore  = "Bef.|bef|before"
)

// Calendar represents the calendar system used.
type Calendar string

const (
        CalendarGregorian Calendar = "GREGORIAN"
        CalendarJulian    Calendar = "JULIAN"
        CalendarHebrew    Calendar = "HEBREW"
        CalendarFrench    Calendar = "FRENCH"
        CalendarUnknown   Calendar = "UNKNOWN"
)

// GedcomDate represents a parsed GEDCOM date with structured components.
type GedcomDate struct {
        Original string   // Original GEDCOM date string
        Type     DateType // EXACT, ABOUT, BEFORE, AFTER, BETWEEN, etc.
        Calendar Calendar // GREGORIAN, JULIAN, HEBREW, etc.

        // Exact date components
        Year  int
        Month int
        Day   int

        // Range date components
        StartYear  int
        StartMonth int
        StartDay   int
        EndYear    int
        EndMonth   int
        EndDay     int

        // Parsed status
        IsParsed   bool
        ParseError error
}

var (
        // Month abbreviations (case-insensitive)
        monthMap = map[string]int{
                "jan": 1, "january": 1, "feb": 2, "february": 2,
                "mar": 3, "march": 3, "apr": 4, "april": 4,
                "may": 5, "jun": 6, "june": 6,
                "jul": 7, "july": 7, "aug": 8, "august": 8,
                "sep": 9, "september": 9, "oct": 10, "october": 10,
                "nov": 11, "november": 11, "dec": 12, "december": 12,
        }

        // Date type prefixes (case-insensitive, with variations)
        dateTypePrefixes = map[string]DateType{
                "abt": DateTypeAbout, "abt.": DateTypeAbout, "about": DateTypeAbout,
                "c.": DateTypeAbout, "ca": DateTypeAbout, "ca.": DateTypeAbout,
                "cca": DateTypeAbout, "cca.": DateTypeAbout, "circa": DateTypeAbout,
                "bef": DateTypeBefore, "bef.": DateTypeBefore, "before": DateTypeBefore,
                "aft": DateTypeAfter, "aft.": DateTypeAfter, "after": DateTypeAfter,
                "bet": DateTypeBetween, "bet.": DateTypeBetween, "between": DateTypeBetween,
                "from": DateTypeFrom,
                "to": DateTypeTo,
        }

        // Patterns for date parsing (case-insensitive)
        exactDatePattern = regexp.MustCompile(`(?i)^(\d{1,2})\s+(\w+)\s+(\d{1,4})$`)
        monthYearPattern = regexp.MustCompile(`(?i)^(\w+)\s+(\d{1,4})$`)
        yearOnlyPattern  = regexp.MustCompile(`^\d{1,4}$`)
        betweenPattern   = regexp.MustCompile(`(?i)^(bet|bet\.|between|from)\s+(.+?)\s+(and|to|-)\s+(.+)$`)
        fromToPattern    = regexp.MustCompile(`(?i)^from\s+(.+?)\s+to\s+(.+)$`)
        
        // Enhanced between pattern that handles "BET X AND Y" format
        betweenPatternEnhanced = regexp.MustCompile(`(?i)^(?:bet|bet\.|between|from)\s+(.+?)\s+(?:and|to|-)\s+(.+)$`)
)

// ParseDate parses a GEDCOM date string and returns a GedcomDate.
// Supports various GEDCOM date formats:
//   - "15 JAN 1800" (exact date)
//   - "JAN 1800" (month-year)
//   - "1800" (year only)
//   - "ABT 1850" (about)
//   - "BEF 1900" (before)
//   - "AFT 1900" (after)
//   - "BET 1800 AND 1850" (between)
//   - "FROM 1800 TO 1850" (range)
func ParseDate(dateStr string) (*GedcomDate, error) <span class="cov9" title="92">{
        if dateStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty date string")
        }</span>

        <span class="cov9" title="92">date := &amp;GedcomDate{
                Original:   strings.TrimSpace(dateStr),
                Calendar:   CalendarGregorian, // Default to Gregorian
                IsParsed:   false,
                ParseError: nil,
        }

        // Normalize to lowercase for case-insensitive matching
        normalizedDate := strings.ToLower(strings.TrimSpace(dateStr))

        // Check for date type prefixes (case-insensitive)
        parts := strings.Fields(normalizedDate)
        if len(parts) &gt; 0 </span><span class="cov9" title="92">{
                // Try exact match first
                if dateType, ok := dateTypePrefixes[parts[0]]; ok </span><span class="cov6" title="16">{
                        date.Type = dateType
                        // For BETWEEN and FROM, keep the full string for parsing
                        if dateType == DateTypeBetween || dateType == DateTypeFrom </span>{<span class="cov4" title="6">
                                // Keep original for pattern matching
                        }</span> else<span class="cov5" title="10"> {
                                normalizedDate = strings.Join(parts[1:], " ")
                        }</span>
                }
        }

        // Parse based on type
        <span class="cov9" title="92">var err error
        switch date.Type </span>{
        case DateTypeBetween:<span class="cov4" title="5">
                err = parseBetweenDate(date, normalizedDate)</span>
        case DateTypeFrom:<span class="cov1" title="1">
                err = parseFromToDate(date, normalizedDate)</span>
        default:<span class="cov9" title="86">
                err = parseSingleDate(date, normalizedDate)</span>
        }

        <span class="cov9" title="92">if err != nil </span><span class="cov0" title="0">{
                date.ParseError = err
                return date, err
        }</span>

        // If no type was set, default to EXACT
        <span class="cov9" title="92">if date.Type == "" </span><span class="cov9" title="76">{
                date.Type = DateTypeExact
        }</span>

        <span class="cov9" title="92">date.IsParsed = true
        return date, nil</span>
}

// parseSingleDate parses a single date (exact, about, before, after, or year-only).
func parseSingleDate(date *GedcomDate, dateStr string) error <span class="cov9" title="98">{
        // Normalize to lowercase for case-insensitive matching
        dateStr = strings.ToLower(strings.TrimSpace(dateStr))

        // Try exact date: "15 jan 1800" or "15 JAN 1800"
        if matches := exactDatePattern.FindStringSubmatch(dateStr); matches != nil </span><span class="cov7" title="39">{
                day, _ := strconv.Atoi(matches[1])
                monthStr := strings.ToLower(matches[2])
                year, _ := strconv.Atoi(matches[3])

                month, ok := monthMap[monthStr]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid month: %s", monthStr)
                }</span>

                // Validate the date
                <span class="cov7" title="39">_, err := time.Parse("2006-01-02", fmt.Sprintf("%04d-%02d-%02d", year, month, day))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid date: %d %s %d", day, monthStr, year)
                }</span>

                <span class="cov7" title="39">date.Day = day
                date.Month = month
                date.Year = year
                return nil</span>
        }

        // Try month-year: "JAN 1800" or "january 1800"
        <span class="cov8" title="59">if matches := monthYearPattern.FindStringSubmatch(dateStr); matches != nil </span><span class="cov4" title="5">{
                monthStr := strings.ToLower(matches[1])
                year, _ := strconv.Atoi(matches[2])

                month, ok := monthMap[monthStr]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid month: %s", monthStr)
                }</span>

                <span class="cov4" title="5">date.Month = month
                date.Year = year
                return nil</span>
        }

        // Try year only: "1800"
        <span class="cov8" title="54">if yearOnlyPattern.MatchString(dateStr) </span><span class="cov8" title="54">{
                year, _ := strconv.Atoi(dateStr)
                if year &lt; 0 || year &gt; 9999 </span><span class="cov0" title="0">{
                        return fmt.Errorf("year out of range: %d", year)
                }</span>
                <span class="cov8" title="54">date.Year = year
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("unable to parse date: %s", dateStr)</span>
}

// parseBetweenDate parses a "BET X AND Y" date (case-insensitive).
func parseBetweenDate(date *GedcomDate, dateStr string) error <span class="cov4" title="5">{
        // Use enhanced pattern that captures only the dates, not the keywords
        matches := betweenPatternEnhanced.FindStringSubmatch(dateStr)
        if matches == nil </span><span class="cov0" title="0">{
                // Fallback to original pattern
                matches = betweenPattern.FindStringSubmatch(dateStr)
                if matches == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid BETWEEN date format: %s", dateStr)
                }</span>
                // Original pattern: [0]=full, [1]=keyword, [2]=start, [3]=connector, [4]=end
                <span class="cov0" title="0">if len(matches) &gt;= 5 </span><span class="cov0" title="0">{
                        startStr := strings.TrimSpace(matches[2])
                        endStr := strings.TrimSpace(matches[4])
                        return parseBetweenDates(date, startStr, endStr)
                }</span>
        }

        // Enhanced pattern: [0]=full, [1]=start, [2]=end
        <span class="cov4" title="5">startStr := strings.TrimSpace(matches[1])
        endStr := strings.TrimSpace(matches[2])
        return parseBetweenDates(date, startStr, endStr)</span>
}

// parseBetweenDates parses the start and end dates for a BETWEEN range.
func parseBetweenDates(date *GedcomDate, startStr, endStr string) error <span class="cov4" title="5">{

        // Parse start date
        startDate := &amp;GedcomDate{}
        if err := parseSingleDate(startDate, startStr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid start date in BETWEEN: %w", err)
        }</span>
        <span class="cov4" title="5">date.StartYear = startDate.Year
        date.StartMonth = startDate.Month
        date.StartDay = startDate.Day

        // Parse end date
        endDate := &amp;GedcomDate{}
        if err := parseSingleDate(endDate, endStr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid end date in BETWEEN: %w", err)
        }</span>
        <span class="cov4" title="5">date.EndYear = endDate.Year
        date.EndMonth = endDate.Month
        date.EndDay = endDate.Day

        return nil</span>
}

// parseFromToDate parses a "FROM X TO Y" date (case-insensitive).
func parseFromToDate(date *GedcomDate, dateStr string) error <span class="cov1" title="1">{
        matches := fromToPattern.FindStringSubmatch(dateStr)
        if matches == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid FROM-TO date format: %s", dateStr)
        }</span>

        <span class="cov1" title="1">date.Type = DateTypeFromTo

        startStr := strings.TrimSpace(matches[1])
        endStr := strings.TrimSpace(matches[2])

        // Parse start date
        startDate := &amp;GedcomDate{}
        if err := parseSingleDate(startDate, startStr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid start date in FROM-TO: %w", err)
        }</span>
        <span class="cov1" title="1">date.StartYear = startDate.Year
        date.StartMonth = startDate.Month
        date.StartDay = startDate.Day

        // Parse end date
        endDate := &amp;GedcomDate{}
        if err := parseSingleDate(endDate, endStr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid end date in FROM-TO: %w", err)
        }</span>
        <span class="cov1" title="1">date.EndYear = endDate.Year
        date.EndMonth = endDate.Month
        date.EndDay = endDate.Day

        return nil</span>
}

// IsValid returns true if the date was successfully parsed.
func (gd *GedcomDate) IsValid() bool <span class="cov10" title="123">{
        return gd.IsParsed &amp;&amp; gd.ParseError == nil
}</span>

// IsRange returns true if this is a range date (BETWEEN or FROM-TO).
func (gd *GedcomDate) IsRange() bool <span class="cov9" title="90">{
        return gd.Type == DateTypeBetween || gd.Type == DateTypeFromTo
}</span>

// ToTime converts the date to a time.Time.
// For range dates, returns the start date.
// Returns error if date is invalid or cannot be converted.
func (gd *GedcomDate) ToTime() (time.Time, error) <span class="cov1" title="1">{
        if !gd.IsValid() </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("invalid date: %v", gd.ParseError)
        }</span>

        <span class="cov1" title="1">if gd.IsRange() </span><span class="cov0" title="0">{
                return time.Date(gd.StartYear, time.Month(gd.StartMonth), gd.StartDay, 0, 0, 0, 0, time.UTC), nil
        }</span>

        // Default to January 1st if month/day not specified
        <span class="cov1" title="1">month := gd.Month
        if month == 0 </span><span class="cov0" title="0">{
                month = 1
        }</span>
        <span class="cov1" title="1">day := gd.Day
        if day == 0 </span><span class="cov0" title="0">{
                day = 1
        }</span>

        <span class="cov1" title="1">return time.Date(gd.Year, time.Month(month), day, 0, 0, 0, 0, time.UTC), nil</span>
}

// ToISO8601 converts the date to ISO 8601 format (YYYY-MM-DD).
// For range dates, returns the start date.
// Returns empty string if date is invalid.
func (gd *GedcomDate) ToISO8601() string <span class="cov4" title="5">{
        if !gd.IsValid() </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov4" title="5">if gd.IsRange() </span><span class="cov1" title="1">{
                return formatISO8601(gd.StartYear, gd.StartMonth, gd.StartDay)
        }</span>

        <span class="cov3" title="4">return formatISO8601(gd.Year, gd.Month, gd.Day)</span>
}

// formatISO8601 formats year, month, day as ISO 8601.
func formatISO8601(year, month, day int) string <span class="cov4" title="5">{
        if year == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov4" title="5">monthStr := fmt.Sprintf("%02d", month)
        dayStr := fmt.Sprintf("%02d", day)

        if month == 0 </span><span class="cov2" title="2">{
                return fmt.Sprintf("%04d", year)
        }</span>
        <span class="cov3" title="3">if day == 0 </span><span class="cov1" title="1">{
                return fmt.Sprintf("%04d-%s", year, monthStr)
        }</span>

        <span class="cov2" title="2">return fmt.Sprintf("%04d-%s-%s", year, monthStr, dayStr)</span>
}

// Earliest returns the earliest possible time for this date.
func (gd *GedcomDate) Earliest() time.Time <span class="cov4" title="6">{
        if !gd.IsValid() </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>

        <span class="cov4" title="6">if gd.IsRange() </span><span class="cov0" title="0">{
                month := gd.StartMonth
                if month == 0 </span><span class="cov0" title="0">{
                        month = 1
                }</span>
                <span class="cov0" title="0">day := gd.StartDay
                if day == 0 </span><span class="cov0" title="0">{
                        day = 1
                }</span>
                <span class="cov0" title="0">return time.Date(gd.StartYear, time.Month(month), day, 0, 0, 0, 0, time.UTC)</span>
        }

        <span class="cov4" title="6">month := gd.Month
        if month == 0 </span><span class="cov0" title="0">{
                month = 1
        }</span>
        <span class="cov4" title="6">day := gd.Day
        if day == 0 </span><span class="cov0" title="0">{
                day = 1
        }</span>

        // Adjust for date types
        <span class="cov4" title="6">switch gd.Type </span>{
        case DateTypeBefore:<span class="cov0" title="0">
                // Before: use earliest possible (year 1)
                return time.Date(1, 1, 1, 0, 0, 0, 0, time.UTC)</span>
        case DateTypeAfter:<span class="cov0" title="0">
                // After: use the date itself
                return time.Date(gd.Year, time.Month(month), day, 0, 0, 0, 0, time.UTC)</span>
        case DateTypeAbout:<span class="cov0" title="0">
                // About: use the date itself (could subtract years for range, but keeping simple)
                return time.Date(gd.Year, time.Month(month), day, 0, 0, 0, 0, time.UTC)</span>
        default:<span class="cov4" title="6">
                return time.Date(gd.Year, time.Month(month), day, 0, 0, 0, 0, time.UTC)</span>
        }
}

// Latest returns the latest possible time for this date.
func (gd *GedcomDate) Latest() time.Time <span class="cov0" title="0">{
        if !gd.IsValid() </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>

        <span class="cov0" title="0">if gd.IsRange() </span><span class="cov0" title="0">{
                month := gd.EndMonth
                if month == 0 </span><span class="cov0" title="0">{
                        month = 12
                }</span>
                <span class="cov0" title="0">day := gd.EndDay
                if day == 0 </span><span class="cov0" title="0">{
                        day = 31 // Last day of month (approximate)
                }</span>
                <span class="cov0" title="0">return time.Date(gd.EndYear, time.Month(month), day, 23, 59, 59, 0, time.UTC)</span>
        }

        <span class="cov0" title="0">month := gd.Month
        if month == 0 </span><span class="cov0" title="0">{
                month = 12
        }</span>
        <span class="cov0" title="0">day := gd.Day
        if day == 0 </span><span class="cov0" title="0">{
                day = 31 // Last day of month (approximate)
        }</span>

        // Adjust for date types
        <span class="cov0" title="0">switch gd.Type </span>{
        case DateTypeBefore:<span class="cov0" title="0">
                // Before: use the date itself
                return time.Date(gd.Year, time.Month(month), day, 23, 59, 59, 0, time.UTC)</span>
        case DateTypeAfter:<span class="cov0" title="0">
                // After: use latest possible (year 9999)
                return time.Date(9999, 12, 31, 23, 59, 59, 0, time.UTC)</span>
        case DateTypeAbout:<span class="cov0" title="0">
                // About: use the date itself (could add years for range, but keeping simple)
                return time.Date(gd.Year, time.Month(month), day, 23, 59, 59, 0, time.UTC)</span>
        default:<span class="cov0" title="0">
                return time.Date(gd.Year, time.Month(month), day, 23, 59, 59, 0, time.UTC)</span>
        }
}

// Compare compares two dates. Returns:
//   - -1 if this date is before other
//   - 0 if dates are equal
//   - 1 if this date is after other
//
// Uses earliest time for comparison.
func (gd *GedcomDate) Compare(other *GedcomDate) int <span class="cov3" title="3">{
        if !gd.IsValid() || !other.IsValid() </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov3" title="3">thisEarliest := gd.Earliest()
        otherEarliest := other.Earliest()

        if thisEarliest.Before(otherEarliest) </span><span class="cov1" title="1">{
                return -1
        }</span>
        <span class="cov2" title="2">if thisEarliest.After(otherEarliest) </span><span class="cov1" title="1">{
                return 1
        }</span>
        <span class="cov1" title="1">return 0</span>
}

// String returns a string representation of the date.
func (gd *GedcomDate) String() string <span class="cov3" title="4">{
        if !gd.IsValid() </span><span class="cov0" title="0">{
                return gd.Original
        }</span>

        <span class="cov3" title="4">if gd.IsRange() </span><span class="cov1" title="1">{
                start := formatDateComponents(gd.StartYear, gd.StartMonth, gd.StartDay)
                end := formatDateComponents(gd.EndYear, gd.EndMonth, gd.EndDay)
                if gd.Type == DateTypeBetween </span><span class="cov1" title="1">{
                        return fmt.Sprintf("BET %s AND %s", start, end)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("FROM %s TO %s", start, end)</span>
        }

        <span class="cov3" title="3">dateStr := formatDateComponents(gd.Year, gd.Month, gd.Day)
        if gd.Type != DateTypeExact </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s %s", gd.Type, dateStr)
        }</span>

        <span class="cov2" title="2">return dateStr</span>
}

// formatDateComponents formats year, month, day as GEDCOM date string.
func formatDateComponents(year, month, day int) string <span class="cov4" title="5">{
        if year == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov4" title="5">if month == 0 </span><span class="cov3" title="3">{
                return fmt.Sprintf("%d", year)
        }</span>

        <span class="cov2" title="2">monthNames := []string{"", "JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"}
        monthStr := monthNames[month]

        if day == 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s %d", monthStr, year)
        }</span>

        <span class="cov2" title="2">return fmt.Sprintf("%d %s %d", day, monthStr, year)</span>
}

// DateConstraintFromString returns the constraint for the provided keyword.
// If the word is not understood, DateConstraintExact will be returned.
// This function is not case sensitive.
func DateConstraintFromString(word string) DateConstraint <span class="cov5" title="14">{
        lowerWord := strings.ToLower(strings.TrimSpace(word))
        if lowerWord == "" </span><span class="cov1" title="1">{
                return DateConstraintExact
        }</span>

        // Check if word matches any of the date word constants
        <span class="cov5" title="13">if wordInWords(lowerWord, DateWordsAbout) </span><span class="cov4" title="6">{
                return DateConstraintAbout
        }</span>
        <span class="cov4" title="7">if wordInWords(lowerWord, DateWordsAfter) </span><span class="cov3" title="3">{
                return DateConstraintAfter
        }</span>
        <span class="cov3" title="4">if wordInWords(lowerWord, DateWordsBefore) </span><span class="cov3" title="3">{
                return DateConstraintBefore
        }</span>

        <span class="cov1" title="1">return DateConstraintExact</span>
}

// wordInWords checks if a word is in a pipe-separated list of words.
func wordInWords(word, words string) bool <span class="cov6" title="24">{
        for _, w := range strings.Split(strings.ToLower(words), "|") </span><span class="cov9" title="114">{
                if w == word </span><span class="cov5" title="12">{
                        return true
                }</span>
        }
        <span class="cov5" title="12">return false</span>
}

// String returns the constraint abbreviation for non-exact dates.
// Exact dates will return an empty string.
func (dc DateConstraint) String() string <span class="cov3" title="4">{
        switch dc </span>{
        case DateConstraintAbout:<span class="cov1" title="1">
                return strings.Split(DateWordsAbout, "|")[0]</span>
        case DateConstraintAfter:<span class="cov1" title="1">
                return strings.Split(DateWordsAfter, "|")[0]</span>
        case DateConstraintBefore:<span class="cov1" title="1">
                return strings.Split(DateWordsBefore, "|")[0]</span>
        default:<span class="cov1" title="1">
                return ""</span>
        }
}

// Constraint returns the DateConstraint for this date based on its Type.
func (gd *GedcomDate) Constraint() DateConstraint <span class="cov6" title="18">{
        switch gd.Type </span>{
        case DateTypeAbout:<span class="cov2" title="2">
                return DateConstraintAbout</span>
        case DateTypeBefore:<span class="cov0" title="0">
                return DateConstraintBefore</span>
        case DateTypeAfter:<span class="cov1" title="1">
                return DateConstraintAfter</span>
        default:<span class="cov6" title="15">
                return DateConstraintExact</span>
        }
}

// Years returns the number of years of a date as a floating-point.
// It can be used as an approximation to get a general idea of how far apart dates are.
//
// For specific dates, it's calculated as the number of days that have passed,
// divided by the number of days in that year (to correct for leap years).
//
// Since some date components can be missing (like the day or month), Years
// compensates by returning the midpoint (average) of the maximum and minimum value.
//
// When only a year is provided, 0.5 will be added to the year.
func (gd *GedcomDate) Years() float64 <span class="cov7" title="30">{
        if !gd.IsValid() </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov7" title="30">if gd.IsRange() </span><span class="cov1" title="1">{
                start := gd.getStartDateForYears()
                end := gd.getEndDateForYears()
                return (start.Years() + end.Years()) / 2.0
        }</span>

        <span class="cov7" title="29">return gd.getSingleDateYears()</span>
}

// getSingleDateYears calculates Years for a single (non-range) date.
func (gd *GedcomDate) getSingleDateYears() float64 <span class="cov7" title="29">{
        hasDay := gd.Day != 0
        hasMonth := gd.Month != 0
        hasYear := gd.Year != 0

        if hasDay &amp;&amp; hasMonth &amp;&amp; hasYear </span><span class="cov5" title="12">{
                // Calculate the total number of days in this year to account for leap years
                t := time.Date(gd.Year, time.Month(gd.Month), gd.Day, 0, 0, 0, 0, time.UTC)
                daysInYear := time.Date(t.Year()+1, 1, 1, 0, 0, 0, 0, time.UTC).
                        AddDate(0, 0, -1).YearDay() + 1

                fractional := float64(t.YearDay()) / float64(daysInYear)
                return float64(t.Year()) + fractional
        }</span>

        <span class="cov6" title="17">if hasMonth &amp;&amp; hasYear </span><span class="cov2" title="2">{
                // Average of first and last day of month
                start := time.Date(gd.Year, time.Month(gd.Month), 1, 0, 0, 0, 0, time.UTC)
                lastDay := time.Date(gd.Year, time.Month(gd.Month)+1, 1, 0, 0, 0, 0, time.UTC).
                        AddDate(0, 0, -1).Day()

                startDaysInYear := time.Date(start.Year()+1, 1, 1, 0, 0, 0, 0, time.UTC).
                        AddDate(0, 0, -1).YearDay() + 1
                endDaysInYear := startDaysInYear // Same year

                startFractional := float64(start.YearDay()) / float64(startDaysInYear)
                endFractional := float64(lastDay) / float64(endDaysInYear)

                startYears := float64(start.Year()) + startFractional
                endYears := float64(start.Year()) + endFractional

                return (startYears + endYears) / 2
        }</span>

        <span class="cov6" title="15">if hasYear </span><span class="cov6" title="15">{
                return float64(gd.Year) + 0.5
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// getStartDateForYears returns a GedcomDate representing the start of the range.
func (gd *GedcomDate) getStartDateForYears() *GedcomDate <span class="cov1" title="1">{
        return &amp;GedcomDate{
                Year:  gd.StartYear,
                Month: gd.StartMonth,
                Day:   gd.StartDay,
                Type:  DateTypeExact,
                IsParsed: true,
        }
}</span>

// getEndDateForYears returns a GedcomDate representing the end of the range.
func (gd *GedcomDate) getEndDateForYears() *GedcomDate <span class="cov1" title="1">{
        return &amp;GedcomDate{
                Year:  gd.EndYear,
                Month: gd.EndMonth,
                Day:   gd.EndDay,
                Type:  DateTypeExact,
                IsParsed: true,
        }
}</span>

// Similarity returns a value from 0.0 to 1.0 to identify how similar two dates are.
// 1.0 means the dates are exactly the same, 0.0 means they are not similar at all.
//
// Similarity is calculated on a parabola that awards higher values to dates that
// are proportionally closer to each other.
//
// The maxYears allows the error margin to be adjusted. Dates that are further
// apart (in any direction) than maxYears will always return 0.0.
func (gd *GedcomDate) Similarity(other *GedcomDate, maxYears float64) float64 <span class="cov4" title="5">{
        if !gd.IsValid() || !other.IsValid() </span><span class="cov0" title="0">{
                return 0.5 // Return neutral value when dates are invalid
        }</span>

        <span class="cov4" title="5">leftYears := gd.Years()
        rightYears := other.Years()
        yearsApart := leftYears - rightYears
        if yearsApart &lt; 0 </span><span class="cov3" title="4">{
                yearsApart = -yearsApart
        }</span>

        <span class="cov4" title="5">similarity := math.Pow(yearsApart/maxYears, 2)

        // When dates are too far apart, similarity goes asymptotic
        if similarity &gt; 1 </span><span class="cov2" title="2">{
                return 0
        }</span>

        <span class="cov3" title="3">return 1 - similarity</span>
}

// IsExact returns true if all parts of the date are complete and the date
// constraint is exact. This means it points to a specific day.
func (gd *GedcomDate) IsExact() bool <span class="cov4" title="6">{
        if !gd.IsValid() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="6">if gd.IsRange() </span><span class="cov1" title="1">{
                return gd.StartDay != 0 &amp;&amp; gd.StartMonth != 0 &amp;&amp; gd.StartYear != 0 &amp;&amp;
                        gd.EndDay != 0 &amp;&amp; gd.EndMonth != 0 &amp;&amp; gd.EndYear != 0 &amp;&amp;
                        gd.Type == DateTypeExact
        }</span>

        <span class="cov4" title="5">return gd.Day != 0 &amp;&amp; gd.Month != 0 &amp;&amp; gd.Year != 0 &amp;&amp; gd.Type == DateTypeExact</span>
}

// IsBefore returns true if this date is before the other date.
func (gd *GedcomDate) IsBefore(other *GedcomDate) bool <span class="cov2" title="2">{
        if !gd.IsValid() || !other.IsValid() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov2" title="2">leftYears := gd.Years()
        rightYears := other.Years()

        return leftYears &lt; rightYears</span>
}

// IsAfter returns true if this date is after the other date.
func (gd *GedcomDate) IsAfter(other *GedcomDate) bool <span class="cov1" title="1">{
        if !gd.IsValid() || !other.IsValid() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov1" title="1">leftYears := gd.Years()
        rightYears := other.Years()

        return leftYears &gt; rightYears</span>
}

// Equals compares two dates taking into consideration the date constraint.
//
// Unlike Compare(), Equals() takes into account what the date and its constraint
// represents, rather than just its raw value.
//
// For example, "3 Sep 1943" == "Bef. Oct 1943" returns true because 3 Sep 1943
// is before Oct 1943.
//
// If either date is invalid, false is always returned.
func (gd *GedcomDate) Equals(other *GedcomDate) bool <span class="cov5" title="9">{
        if !gd.IsValid() || !other.IsValid() </span><span class="cov0" title="0">{
                return false
        }</span>

        // If both dates are exactly the same (same day, month, year, constraint), return true
        <span class="cov5" title="9">if gd.Is(other) </span><span class="cov4" title="5">{
                return true
        }</span>

        // Use constraint-aware comparison matrix
        <span class="cov3" title="4">matchers := [][]func(d1, d2 *GedcomDate) bool{
                {equalsA, equalsA, equalsB, equalsC}, // Exact row
                {equalsA, equalsA, equalsD, equalsD}, // About row
                {equalsC, equalsD, equalsC, equalsD}, // Before row
                {equalsB, equalsD, equalsD, equalsB}, // After row
        }

        c1 := gd.Constraint()
        c2 := other.Constraint()

        return matchers[c2][c1](gd, other)</span>
}

// Is compares two dates. Dates are only considered to be the same if the day,
// month, year and constraint are all the same.
func (gd *GedcomDate) Is(other *GedcomDate) bool <span class="cov5" title="9">{
        if !gd.IsValid() || !other.IsValid() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov5" title="9">if gd.IsRange() != other.IsRange() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov5" title="9">if gd.IsRange() </span><span class="cov0" title="0">{
                return gd.StartDay == other.StartDay &amp;&amp;
                        gd.StartMonth == other.StartMonth &amp;&amp;
                        gd.StartYear == other.StartYear &amp;&amp;
                        gd.EndDay == other.EndDay &amp;&amp;
                        gd.EndMonth == other.EndMonth &amp;&amp;
                        gd.EndYear == other.EndYear &amp;&amp;
                        gd.Constraint() == other.Constraint()
        }</span>

        <span class="cov5" title="9">return gd.Day == other.Day &amp;&amp;
                gd.Month == other.Month &amp;&amp;
                gd.Year == other.Year &amp;&amp;
                gd.Constraint() == other.Constraint()</span>
}

// equalsA: Match if the day, month and year are all equal.
func equalsA(d1, d2 *GedcomDate) bool <span class="cov3" title="3">{
        if d1.IsRange() || d2.IsRange() </span><span class="cov0" title="0">{
                return false // Ranges need special handling
        }</span>

        <span class="cov3" title="3">if d1.Day != d2.Day </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov2" title="2">if d1.Month != d2.Month </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="2">return d1.Year == d2.Year</span>
}

// equalsB: Match if left.Years() &gt; right.Years().
func equalsB(d1, d2 *GedcomDate) bool <span class="cov1" title="1">{
        return d1.Years() &gt; d2.Years()
}</span>

// equalsC: Match if left.Years() &lt; right.Years().
func equalsC(d1, d2 *GedcomDate) bool <span class="cov0" title="0">{
        return d1.Years() &lt; d2.Years()
}</span>

// equalsD: Never a match.
func equalsD(d1, d2 *GedcomDate) bool <span class="cov0" title="0">{
        return false
}</span>

// IsZero returns true if the day, month and year are not provided.
func (gd *GedcomDate) IsZero() bool <span class="cov3" title="3">{
        if gd.IsRange() </span><span class="cov0" title="0">{
                return (gd.StartDay == 0 &amp;&amp; gd.StartMonth == 0 &amp;&amp; gd.StartYear == 0) &amp;&amp;
                        (gd.EndDay == 0 &amp;&amp; gd.EndMonth == 0 &amp;&amp; gd.EndYear == 0)
        }</span>

        <span class="cov3" title="3">return gd.Day == 0 &amp;&amp; gd.Month == 0 &amp;&amp; gd.Year == 0</span>
}

// Sub returns the duration between two dates.
func (gd *GedcomDate) Sub(other *GedcomDate) Duration <span class="cov0" title="0">{
        if !gd.IsValid() || !other.IsValid() </span><span class="cov0" title="0">{
                return NewDuration(0, false, true)
        }</span>

        <span class="cov0" title="0">a := gd.Earliest()
        b := other.Earliest()

        isKnown := gd.ParseError == nil &amp;&amp; other.ParseError == nil
        isEstimate := !gd.IsExact() || !other.IsExact()

        return NewDuration(a.Sub(b), isKnown, isEstimate)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package types

// DateNode represents a structured date node.
// Wraps GedcomDate and DateRange to provide a node-like interface.
type DateNode struct {
        // Date is the parsed GedcomDate
        Date *GedcomDate

        // DateRange is the parsed DateRange (for compatibility with elliotchance API)
        DateRange DateRange

        // Original is the original date string
        Original string

        // AlreadyParsed tracks if we've already parsed the date (for caching)
        alreadyParsed bool
}

// NewDateNode creates a new DateNode from a date string.
func NewDateNode(dateStr string) *DateNode <span class="cov8" title="8">{
        if dateStr == "" </span><span class="cov0" title="0">{
                return &amp;DateNode{}
        }</span>

        <span class="cov8" title="8">dn := &amp;DateNode{
                Original: dateStr,
        }

        // Parse the date
        dn.parse()

        return dn</span>
}

// NewDateNodeFromLine creates a DateNode from a GedcomLine (DATE tag).
func NewDateNodeFromLine(line *GedcomLine) *DateNode <span class="cov8" title="7">{
        if line == nil || line.Tag != "DATE" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="7">return NewDateNode(line.Value)</span>
}

// parse parses the date string into GedcomDate and DateRange.
func (dn *DateNode) parse() <span class="cov10" title="12">{
        if dn.alreadyParsed || dn.Original == "" </span><span class="cov6" title="4">{
                return
        }</span>

        // Parse as GedcomDate
        <span class="cov8" title="8">date, err := ParseDate(dn.Original)
        if err == nil </span><span class="cov8" title="8">{
                dn.Date = date
        }</span>

        // Also create DateRange for compatibility
        <span class="cov8" title="8">dn.DateRange = NewDateRangeWithString(dn.Original)

        dn.alreadyParsed = true</span>
}

// IsValid returns true if the date was successfully parsed.
func (dn *DateNode) IsValid() bool <span class="cov4" title="3">{
        if dn == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov4" title="3">dn.parse()
        return dn.Date != nil &amp;&amp; dn.Date.IsValid()</span>
}

// StartDate returns the start date of the date range.
func (dn *DateNode) StartDate() *GedcomDate <span class="cov0" title="0">{
        if dn == nil || !dn.IsValid() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return dn.DateRange.StartDate()</span>
}

// EndDate returns the end date of the date range.
func (dn *DateNode) EndDate() *GedcomDate <span class="cov0" title="0">{
        if dn == nil || !dn.IsValid() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return dn.DateRange.EndDate()</span>
}

// StartAndEndDates returns both start and end dates.
func (dn *DateNode) StartAndEndDates() (*GedcomDate, *GedcomDate) <span class="cov0" title="0">{
        if dn == nil || !dn.IsValid() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return dn.DateRange.StartAndEndDates()</span>
}

// Years returns the years value of the date.
func (dn *DateNode) Years() float64 <span class="cov0" title="0">{
        if dn == nil || !dn.IsValid() </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return dn.DateRange.Years()</span>
}

// IsExact returns true if the date is exact (specific day).
func (dn *DateNode) IsExact() bool <span class="cov0" title="0">{
        if dn == nil || !dn.IsValid() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return dn.DateRange.IsExact()</span>
}

// Equals compares two date nodes for equality.
func (dn *DateNode) Equals(other *DateNode) bool <span class="cov0" title="0">{
        if dn == nil || other == nil </span><span class="cov0" title="0">{
                return dn == other
        }</span>

        <span class="cov0" title="0">if !dn.IsValid() || !other.IsValid() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return dn.DateRange.Equals(other.DateRange)</span>
}

// Similarity returns the similarity between two date nodes.
func (dn *DateNode) Similarity(other *DateNode, maxYears float64) float64 <span class="cov0" title="0">{
        if dn == nil || other == nil </span><span class="cov0" title="0">{
                return 0.5
        }</span>

        <span class="cov0" title="0">if !dn.IsValid() || !other.IsValid() </span><span class="cov0" title="0">{
                return 0.5
        }</span>

        <span class="cov0" title="0">return dn.DateRange.Similarity(other.DateRange, maxYears)</span>
}

// String returns the string representation of the date.
func (dn *DateNode) String() string <span class="cov1" title="1">{
        if dn == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">dn.parse()
        if dn.Date != nil </span><span class="cov1" title="1">{
                return dn.Date.String()
        }</span>
        <span class="cov0" title="0">return dn.Original</span>
}

</pre>
		
		<pre class="file" id="file2" style="display: none">package types

import (
        "fmt"
        "math"
        "regexp"
        "strings"
)

// DateRange represents a period of time.
// The minimum possible period is 1 day and ranges only have a resolution of a single day.
type DateRange struct {
        start          *GedcomDate
        end            *GedcomDate
        originalString string
}

// NewZeroDateRange creates a new zero DateRange.
func NewZeroDateRange() DateRange <span class="cov0" title="0">{
        return DateRange{}
}</span>

// NewDateRange creates a new date range between two provided dates.
// It is expected that the start date be less than or equal to the end date.
func NewDateRange(start, end *GedcomDate) DateRange <span class="cov5" title="6">{
        return DateRange{
                start: start,
                end:   end,
        }
}</span>

// NewDateRangeWithString creates a DateRange from a GEDCOM date string.
func NewDateRangeWithString(s string) DateRange <span class="cov8" title="14">{
        dateString := cleanSpace(s)

        // Try to match a range first
        dateRangeRegexp := regexp.MustCompile(
                fmt.Sprintf(`(?i)^(%s) (.+) (%s) (.+)$`, DateWordsBetween, DateWordsAnd))
        parts := dateRangeRegexp.FindStringSubmatch(dateString)

        if len(parts) &gt; 0 </span><span class="cov5" title="6">{
                datePart1 := parseDatePartsForRange(parts[2], false)
                datePart2 := parseDatePartsForRange(parts[4], true)
                return NewDateRange(datePart1, datePart2)
        }</span>

        // Single date - create range with same start and end
        <span class="cov6" title="8">datePart1 := parseDatePartsForRange(dateString, false)
        datePart2 := parseDatePartsForRange(dateString, true)

        return DateRange{
                start:          datePart1,
                end:            datePart2,
                originalString: s,
        }</span>
}

// parseDatePartsForRange parses date parts for a DateRange.
// This is a simplified version that creates a GedcomDate.
func parseDatePartsForRange(dateString string, isEndOfRange bool) *GedcomDate <span class="cov10" title="28">{
        // Use the existing ParseDate function
        date, err := ParseDate(dateString)
        if err != nil </span><span class="cov0" title="0">{
                // Return invalid date with parse error
                return &amp;GedcomDate{
                        Original:   dateString,
                        ParseError: err,
                        IsParsed:   false,
                }
        }</span>

        <span class="cov10" title="28">return date</span>
}

// cleanSpace works similar to strings.TrimSpace except that it also replaces
// consecutive spaces anywhere in the string with a single space.
func cleanSpace(s string) string <span class="cov8" title="14">{
        // Replace twice if there is an odd number of spaces in a row
        s = strings.Replace(s, "  ", " ", -1)
        s = strings.Replace(s, "  ", " ", -1)

        // Trim whatever spaces are left on either side
        return strings.TrimSpace(s)
}</span>

// StartDate returns the lower boundary of the date range.
func (dr DateRange) StartDate() *GedcomDate <span class="cov6" title="7">{
        if dr.start == nil </span><span class="cov0" title="0">{
                return &amp;GedcomDate{}
        }</span>
        <span class="cov6" title="7">return dr.start</span>
}

// EndDate returns the upper boundary of the date range.
func (dr DateRange) EndDate() *GedcomDate <span class="cov6" title="7">{
        if dr.end == nil </span><span class="cov0" title="0">{
                return &amp;GedcomDate{}
        }</span>
        <span class="cov6" title="7">return dr.end</span>
}

// StartAndEndDates returns both start and end dates.
func (dr DateRange) StartAndEndDates() (*GedcomDate, *GedcomDate) <span class="cov0" title="0">{
        return dr.StartDate(), dr.EndDate()
}</span>

// Years works in a similar way to GedcomDate.Years() but also takes into
// consideration the StartDate() and EndDate() values of a whole date range.
// It does this by averaging out the Years() value of the StartDate() and EndDate() values.
func (dr DateRange) Years() float64 <span class="cov3" title="3">{
        start := dr.StartDate()
        end := dr.EndDate()

        if start.IsZero() &amp;&amp; end.IsZero() </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov3" title="3">return (start.Years() + end.Years()) / 2.0</span>
}

// Similarity returns a value from 0.0 to 1.0 to identify how similar two date ranges are.
// 1.0 means the dates are exactly the same, 0.0 means they are not similar at all.
//
// Similarity is calculated on a parabola that awards higher values to dates that
// are proportionally closer to each other.
func (dr DateRange) Similarity(other DateRange, maxYears float64) float64 <span class="cov1" title="1">{
        leftYears := dr.Years()
        rightYears := other.Years()
        yearsApart := leftYears - rightYears
        if yearsApart &lt; 0 </span><span class="cov1" title="1">{
                yearsApart = -yearsApart
        }</span>

        <span class="cov1" title="1">similarity := math.Pow(yearsApart/maxYears, 2)

        // When dates are too far apart, similarity goes asymptotic
        if similarity &gt; 1 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov1" title="1">return 1 - similarity</span>
}

// Equals compares the values of two date ranges taking into consideration the date constraint.
func (dr DateRange) Equals(other DateRange) bool <span class="cov2" title="2">{
        // Compare dates by value range
        matchStartDate := dr.StartDate().Equals(other.StartDate())
        matchEndDate := dr.EndDate().Equals(other.EndDate())

        return matchStartDate &amp;&amp; matchEndDate
}</span>

// IsBefore returns true if the start date is before the other start date.
func (dr DateRange) IsBefore(other DateRange) bool <span class="cov0" title="0">{
        return dr.StartDate().IsBefore(other.StartDate())
}</span>

// IsAfter returns true if the end date is after the other end date.
func (dr DateRange) IsAfter(other DateRange) bool <span class="cov0" title="0">{
        return dr.EndDate().IsAfter(other.EndDate())
}</span>

// IsValid returns true only when the start and end dates are non-zero.
func (dr DateRange) IsValid() bool <span class="cov0" title="0">{
        start, end := dr.StartAndEndDates()
        return !start.IsZero() &amp;&amp; !end.IsZero()
}</span>

// IsExact will return true if the date range represents a single day with an exact constraint.
func (dr DateRange) IsExact() bool <span class="cov0" title="0">{
        start, end := dr.StartAndEndDates()
        startIsExact := start.IsExact()
        endIsExact := end.IsExact()

        return startIsExact &amp;&amp; endIsExact
}</span>

// IsPhrase returns true if the date value is a phrase.
// A phrase is any statement offered as a date when the year is not
// recognizable to a date parser, but which gives information about when an
// event occurred. The date phrase is enclosed in matching parentheses.
func (dr DateRange) IsPhrase() bool <span class="cov0" title="0">{
        if len(dr.originalString) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">firstLetter := dr.originalString[0]
        lastLetter := dr.originalString[len(dr.originalString)-1]

        return firstLetter == '(' &amp;&amp; lastLetter == ')'</span>
}

// String returns a string representation of the date range.
func (dr DateRange) String() string <span class="cov0" title="0">{
        start, end := dr.StartAndEndDates()
        if start.Equals(end) </span><span class="cov0" title="0">{
                return start.String()
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("Bet. %s and %s", start.String(), end.String())</span>
}

// Sub returns the duration between two date ranges.
func (dr DateRange) Sub(other DateRange) (min Duration, max Duration) <span class="cov0" title="0">{
        start := dr.StartDate().Sub(other.StartDate())
        end := dr.EndDate().Sub(other.EndDate())

        return start, end
}</span>

// Duration returns the duration of the date range itself.
func (dr DateRange) Duration() Duration <span class="cov0" title="0">{
        start := dr.StartDate()
        end := dr.EndDate()

        if !start.IsValid() || !end.IsValid() </span><span class="cov0" title="0">{
                return NewDuration(0, false, true)
        }</span>

        <span class="cov0" title="0">startTime := start.Earliest()
        endTime := end.Latest()

        duration := endTime.Sub(startTime)
        return NewDuration(duration, true, !dr.IsExact())</span>
}

</pre>
		
		<pre class="file" id="file3" style="display: none">package types

import (
        "fmt"
        "math"
        "strings"
        "time"
)

// Duration represents a duration that only considers whole-day resolution.
type Duration struct {
        Duration time.Duration

        // IsEstimate indicates if the duration is an estimate
        IsEstimate bool

        // IsKnown indicates if the duration is known (not estimated)
        IsKnown bool
}

// NewExactDuration creates a new exact duration.
func NewExactDuration(duration time.Duration) Duration <span class="cov10" title="3">{
        return NewDuration(duration, true, false)
}</span>

// NewDuration creates a new duration with the specified properties.
// Durations must always be positive.
func NewDuration(duration time.Duration, isKnown, isEstimate bool) Duration <span class="cov10" title="3">{
        // Durations must always be positive
        if duration &lt; 0 </span><span class="cov0" title="0">{
                duration = -duration
        }</span>

        <span class="cov10" title="3">return Duration{
                Duration:   duration,
                IsEstimate: isEstimate,
                IsKnown:    isKnown,
        }</span>
}

// pluralize returns a pluralized string for the given value and word.
func pluralize(value int, word string) string <span class="cov10" title="3">{
        switch value </span>{
        case 0:<span class="cov0" title="0">
                return ""</span>
        case 1:<span class="cov6" title="2">
                return "one " + word</span>
        default:<span class="cov1" title="1">
                return fmt.Sprintf("%d %ss", value, word)</span>
        }
}

// String returns a human-readable string representation of the duration.
func (d Duration) String() string <span class="cov10" title="3">{
        oneDay := time.Duration(24 * time.Hour)
        oneMonth := time.Duration(30.4166 * float64(oneDay))
        oneYear := time.Duration(365 * float64(oneDay))

        if d.Duration &lt; oneDay </span><span class="cov0" title="0">{
                return "one day"
        }</span>

        <span class="cov10" title="3">var parts []string

        if years := int(d.Duration / oneYear); years != 0 </span><span class="cov1" title="1">{
                d.Duration -= time.Duration(years) * oneYear
                parts = append(parts, pluralize(years, "year"))
        }</span>

        <span class="cov10" title="3">if months := int(d.Duration / oneMonth); months != 0 </span><span class="cov0" title="0">{
                d.Duration -= time.Duration(months) * oneMonth
                parts = append(parts, pluralize(months, "month"))
        }</span>

        <span class="cov10" title="3">if days := int(math.Ceil(float64(d.Duration) / float64(oneDay))); days != 0 </span><span class="cov6" title="2">{
                parts = append(parts, pluralize(days, "day"))
        }</span>

        <span class="cov10" title="3">return strings.Join(parts, " and ")</span>
}

</pre>
		
		<pre class="file" id="file4" style="display: none">package types

import (
        "fmt"
        "sync"
)

// ErrorSeverity represents the severity of an error
type ErrorSeverity string

const (
        SeverityHint    ErrorSeverity = "hint"    // Best practices, optimizations
        SeverityInfo    ErrorSeverity = "info"    // Data quality issues, suggestions
        SeverityWarning ErrorSeverity = "warning" // Unlikely but possible situations
        SeveritySevere  ErrorSeverity = "severe"  // Impossible situations, must fix
)

// GedcomError represents a GEDCOM parsing/validation error
type GedcomError struct {
        Severity   ErrorSeverity
        Message    string
        LineNumber int
        Context    string
}

// Error implements the error interface
func (e *GedcomError) Error() string <span class="cov5" title="4">{
        if e.LineNumber &gt; 0 </span><span class="cov4" title="3">{
                return fmt.Sprintf("%s: %s (Line %d)", e.Severity, e.Message, e.LineNumber)
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%s: %s", e.Severity, e.Message)</span>
}

// String returns a string representation of the error
func (e *GedcomError) String() string <span class="cov1" title="1">{
        return e.Error()
}</span>

// ErrorManager manages collection of errors during parsing
type ErrorManager struct {
        mu     sync.RWMutex
        errors []*GedcomError
}

// NewErrorManager creates a new ErrorManager
func NewErrorManager() *ErrorManager <span class="cov7" title="7">{
        return &amp;ErrorManager{
                errors: make([]*GedcomError, 0),
        }
}</span>

// AddError adds an error to the collection
func (em *ErrorManager) AddError(severity ErrorSeverity, message string, lineNumber int, context string) <span class="cov10" title="16">{
        em.mu.Lock()
        defer em.mu.Unlock()
        em.errors = append(em.errors, &amp;GedcomError{
                Severity:   severity,
                Message:    message,
                LineNumber: lineNumber,
                Context:    context,
        })
}</span>

// Errors returns a copy of all errors
func (em *ErrorManager) Errors() []*GedcomError <span class="cov1" title="1">{
        em.mu.RLock()
        defer em.mu.RUnlock()
        result := make([]*GedcomError, len(em.errors))
        copy(result, em.errors)
        return result
}</span>

// HasErrors returns true if there are any errors
func (em *ErrorManager) HasErrors() bool <span class="cov5" title="4">{
        em.mu.RLock()
        defer em.mu.RUnlock()
        return len(em.errors) &gt; 0
}</span>

// HasSevereErrors returns true if there are any severe errors
func (em *ErrorManager) HasSevereErrors() bool <span class="cov5" title="4">{
        em.mu.RLock()
        defer em.mu.RUnlock()
        for _, err := range em.errors </span><span class="cov6" title="5">{
                if err.Severity == SeveritySevere </span><span class="cov3" title="2">{
                        return true
                }</span>
        }
        <span class="cov3" title="2">return false</span>
}

// GetErrorsBySeverity returns all errors of the specified severity
func (em *ErrorManager) GetErrorsBySeverity(severity ErrorSeverity) []*GedcomError <span class="cov3" title="2">{
        em.mu.RLock()
        defer em.mu.RUnlock()
        result := make([]*GedcomError, 0)
        for _, err := range em.errors </span><span class="cov7" title="8">{
                if err.Severity == severity </span><span class="cov5" title="4">{
                        result = append(result, err)
                }</span>
        }
        <span class="cov3" title="2">return result</span>
}

// GetErrorSummary returns a summary of errors by severity
func (em *ErrorManager) GetErrorSummary() map[ErrorSeverity]int <span class="cov1" title="1">{
        em.mu.RLock()
        defer em.mu.RUnlock()
        summary := make(map[ErrorSeverity]int)
        for _, err := range em.errors </span><span class="cov4" title="3">{
                summary[err.Severity]++
        }</span>
        <span class="cov1" title="1">return summary</span>
}

// Clear removes all errors
func (em *ErrorManager) Clear() <span class="cov1" title="1">{
        em.mu.Lock()
        defer em.mu.Unlock()
        em.errors = em.errors[:0]
}</span>

// Count returns the total number of errors
func (em *ErrorManager) Count() int <span class="cov4" title="3">{
        em.mu.RLock()
        defer em.mu.RUnlock()
        return len(em.errors)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package types

import (
        "fmt"
)

// ErrorType represents the type/category of an error
type ErrorType string

const (
        // ErrorTypeParse represents parsing errors
        ErrorTypeParse ErrorType = "parse"
        // ErrorTypeValidation represents validation errors
        ErrorTypeValidation ErrorType = "validation"
        // ErrorTypeQuery represents query errors
        ErrorTypeQuery ErrorType = "query"
        // ErrorTypeStorage represents storage errors
        ErrorTypeStorage ErrorType = "storage"
        // ErrorTypeIO represents I/O errors
        ErrorTypeIO ErrorType = "io"
        // ErrorTypeInternal represents internal errors
        ErrorTypeInternal ErrorType = "internal"
)

// StandardError provides a standardized error structure across packages
type StandardError struct {
        // Type categorizes the error
        Type ErrorType
        // Severity indicates error severity
        Severity ErrorSeverity
        // Message is the error message
        Message string
        // Context provides additional context (component, operation, etc.)
        Context string
        // LineNumber is the line number (if applicable)
        LineNumber int
        // Xref is the record XREF (if applicable)
        Xref string
        // Cause is the underlying error (if any)
        Cause error
}

// Error implements the error interface
func (e *StandardError) Error() string <span class="cov0" title="0">{
        msg := e.Message
        if e.Context != "" </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("[%s] %s", e.Context, msg)
        }</span>
        <span class="cov0" title="0">if e.LineNumber &gt; 0 </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("%s (line %d)", msg, e.LineNumber)
        }</span>
        <span class="cov0" title="0">if e.Xref != "" </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("%s (record %s)", msg, e.Xref)
        }</span>
        <span class="cov0" title="0">if e.Cause != nil </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("%s: %v", msg, e.Cause)
        }</span>
        <span class="cov0" title="0">return msg</span>
}

// Unwrap returns the underlying error for error unwrapping
func (e *StandardError) Unwrap() error <span class="cov0" title="0">{
        return e.Cause
}</span>

// NewStandardError creates a new StandardError
func NewStandardError(errType ErrorType, severity ErrorSeverity, message string) *StandardError <span class="cov0" title="0">{
        return &amp;StandardError{
                Type:     errType,
                Severity: severity,
                Message:  message,
        }
}</span>

// NewStandardErrorWithContext creates a new StandardError with context
func NewStandardErrorWithContext(errType ErrorType, severity ErrorSeverity, message, context string) *StandardError <span class="cov0" title="0">{
        return &amp;StandardError{
                Type:     errType,
                Severity: severity,
                Message:  message,
                Context:  context,
        }
}</span>

// NewStandardErrorWithCause creates a new StandardError with a cause
func NewStandardErrorWithCause(errType ErrorType, severity ErrorSeverity, message string, cause error) *StandardError <span class="cov0" title="0">{
        return &amp;StandardError{
                Type:     errType,
                Severity: severity,
                Message:  message,
                Cause:    cause,
        }
}</span>

// WrapError wraps an existing error as a StandardError
func WrapError(errType ErrorType, severity ErrorSeverity, err error, context string) *StandardError <span class="cov0" title="0">{
        return &amp;StandardError{
                Type:     errType,
                Severity: severity,
                Message:  err.Error(),
                Context:  context,
                Cause:    err,
        }
}</span>

// IsParseError checks if an error is a parse error
func IsParseError(err error) bool <span class="cov0" title="0">{
        if se, ok := err.(*StandardError); ok </span><span class="cov0" title="0">{
                return se.Type == ErrorTypeParse
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsValidationError checks if an error is a validation error
func IsValidationError(err error) bool <span class="cov0" title="0">{
        if se, ok := err.(*StandardError); ok </span><span class="cov0" title="0">{
                return se.Type == ErrorTypeValidation
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsQueryError checks if an error is a query error
func IsQueryError(err error) bool <span class="cov0" title="0">{
        if se, ok := err.(*StandardError); ok </span><span class="cov0" title="0">{
                return se.Type == ErrorTypeQuery
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsStorageError checks if an error is a storage error
func IsStorageError(err error) bool <span class="cov0" title="0">{
        if se, ok := err.(*StandardError); ok </span><span class="cov0" title="0">{
                return se.Type == ErrorTypeStorage
        }</span>
        <span class="cov0" title="0">return false</span>
}

// GetErrorSeverity extracts the severity from an error
func GetErrorSeverity(err error) ErrorSeverity <span class="cov0" title="0">{
        if se, ok := err.(*StandardError); ok </span><span class="cov0" title="0">{
                return se.Severity
        }</span>
        <span class="cov0" title="0">if ge, ok := err.(*GedcomError); ok </span><span class="cov0" title="0">{
                return ge.Severity
        }</span>
        <span class="cov0" title="0">return SeverityWarning</span> // Default severity
}

// GetErrorType extracts the type from an error
func GetErrorType(err error) ErrorType <span class="cov0" title="0">{
        if se, ok := err.(*StandardError); ok </span><span class="cov0" title="0">{
                return se.Type
        }</span>
        <span class="cov0" title="0">return ErrorTypeInternal</span> // Default type
}

</pre>
		
		<pre class="file" id="file6" style="display: none">package types

// Event represents a unified event structure that can represent any GEDCOM event type.
// This includes standard events (BIRT, DEAT, MARR, etc.) and custom events (EVEN with TYPE).
type Event struct {
        // Type identifies the event type (BIRT, DEAT, MARR, or custom type for EVEN)
        Type EventType

        // CustomType is the actual type name for custom events (EVEN with TYPE sub-tag).
        // For standard events, this will be empty.
        CustomType string

        // Date is the structured date associated with the event.
        Date *DateNode

        // Place is the structured place associated with the event.
        Place *PlaceNode

        // Sources contains source citations for this event.
        Sources []string

        // Notes contains note references for this event.
        Notes []string

        // Value is the raw value of the event tag (usually empty for most events).
        Value string

        // OriginalLine is the original GedcomLine that this event was parsed from.
        // This allows access to any additional sub-tags not explicitly represented.
        OriginalLine *GedcomLine
}

// IsCustom returns true if this is a custom event (EVEN tag with TYPE sub-tag).
func (e *Event) IsCustom() bool <span class="cov10" title="8">{
        return e.Type == EventTypeCustom &amp;&amp; e.CustomType != ""
}</span>

// EffectiveType returns the actual event type.
// For custom events, returns the CustomType; otherwise returns the Type.
func (e *Event) EffectiveType() string <span class="cov5" title="3">{
        if e.IsCustom() </span><span class="cov4" title="2">{
                return e.CustomType
        }</span>
        <span class="cov1" title="1">return e.Type.String()</span>
}

// HasDate returns true if the event has a date.
func (e *Event) HasDate() bool <span class="cov0" title="0">{
        return e.Date != nil &amp;&amp; e.Date.IsValid()
}</span>

// HasPlace returns true if the event has a place.
func (e *Event) HasPlace() bool <span class="cov0" title="0">{
        return e.Place != nil &amp;&amp; e.Place.IsValid()
}</span>

// String returns a string representation of the event.
func (e *Event) String() string <span class="cov0" title="0">{
        if e.IsCustom() </span><span class="cov0" title="0">{
                return e.CustomType
        }</span>
        <span class="cov0" title="0">return e.Type.String()</span>
}

</pre>
		
		<pre class="file" id="file7" style="display: none">package types

// EventNode represents a structured wrapper around an Event.
// Provides a node-like interface similar to elliotchance's approach.
type EventNode struct {
        *Event
}

// NewEventNode creates a new EventNode from an Event.
func NewEventNode(event *Event) *EventNode <span class="cov0" title="0">{
        if event == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;EventNode{Event: event}</span>
}

// Dates returns the date nodes associated with this event.
// Returns a slice containing the single DateNode if present.
func (en *EventNode) Dates() []*DateNode <span class="cov0" title="0">{
        if en == nil || en.Date == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return []*DateNode{en.Date}</span>
}

// DateRange returns the date range for this event.
// Returns a zero DateRange if no date is present.
func (en *EventNode) DateRange() DateRange <span class="cov0" title="0">{
        if en == nil || en.Date == nil </span><span class="cov0" title="0">{
                return NewZeroDateRange()
        }</span>
        <span class="cov0" title="0">return en.Date.DateRange</span>
}

// Years returns the years value of the event's date.
// Returns 0 if no date is present.
func (en *EventNode) Years() float64 <span class="cov0" title="0">{
        if en == nil || en.Date == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return en.Date.Years()</span>
}

// Equals compares two event nodes for equality.
// Two events are equal if they have the same type and date.
func (en *EventNode) Equals(other *EventNode) bool <span class="cov0" title="0">{
        if en == nil || other == nil </span><span class="cov0" title="0">{
                return en == other
        }</span>

        <span class="cov0" title="0">if en.Type != other.Type </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if en.IsCustom() &amp;&amp; en.CustomType != other.CustomType </span><span class="cov0" title="0">{
                return false
        }</span>

        // Compare dates if both have them
        <span class="cov0" title="0">if en.Date != nil &amp;&amp; other.Date != nil </span><span class="cov0" title="0">{
                return en.Date.Equals(other.Date)
        }</span>

        <span class="cov0" title="0">return en.Date == other.Date</span>
}

</pre>
		
		<pre class="file" id="file8" style="display: none">package types

import "fmt"

// ParseEvent parses an event from a GedcomLine.
// Handles both standard events (BIRT, DEAT, etc.) and custom events (EVEN with TYPE).
func ParseEvent(eventLine *GedcomLine) (*Event, error) <span class="cov5" title="7">{
        if eventLine == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("event line is nil")
        }</span>

        <span class="cov5" title="7">event := &amp;Event{
                Value:        eventLine.Value,
                OriginalLine: eventLine,
        }

        // Determine event type
        eventTag := eventLine.Tag
        event.Type = ParseEventType(eventTag)

        // Handle custom events (EVEN tag)
        if event.Type == EventTypeCustom </span><span class="cov3" title="3">{
                // For EVEN, the actual type is in the TYPE sub-tag
                typeLines := eventLine.GetLines("TYPE")
                if len(typeLines) &gt; 0 &amp;&amp; typeLines[0].Value != "" </span><span class="cov3" title="3">{
                        event.CustomType = typeLines[0].Value
                }</span> else<span class="cov0" title="0"> {
                        // EVEN without TYPE - use value or default
                        if eventLine.Value != "" </span><span class="cov0" title="0">{
                                event.CustomType = eventLine.Value
                        }</span> else<span class="cov0" title="0"> {
                                event.CustomType = "Unknown"
                        }</span>
                }
        }

        // Parse date
        <span class="cov5" title="7">dateLines := eventLine.GetLines("DATE")
        if len(dateLines) &gt; 0 </span><span class="cov5" title="7">{
                event.Date = NewDateNodeFromLine(dateLines[0])
        }</span>

        // Parse place
        <span class="cov5" title="7">placeLines := eventLine.GetLines("PLAC")
        if len(placeLines) &gt; 0 </span><span class="cov4" title="5">{
                event.Place = NewPlaceNodeFromLine(placeLines[0])
        }</span>

        // Parse sources
        <span class="cov5" title="7">sourceLines := eventLine.GetLines("SOUR")
        event.Sources = make([]string, 0, len(sourceLines))
        for _, sourceLine := range sourceLines </span><span class="cov0" title="0">{
                if sourceLine.XrefID != "" </span><span class="cov0" title="0">{
                        event.Sources = append(event.Sources, sourceLine.XrefID)
                }</span> else<span class="cov0" title="0"> if sourceLine.Value != "" </span><span class="cov0" title="0">{
                        event.Sources = append(event.Sources, sourceLine.Value)
                }</span>
        }

        // Parse notes
        <span class="cov5" title="7">noteLines := eventLine.GetLines("NOTE")
        event.Notes = make([]string, 0, len(noteLines))
        for _, noteLine := range noteLines </span><span class="cov0" title="0">{
                if noteLine.XrefID != "" </span><span class="cov0" title="0">{
                        event.Notes = append(event.Notes, noteLine.XrefID)
                }</span> else<span class="cov0" title="0"> if noteLine.Value != "" </span><span class="cov0" title="0">{
                        event.Notes = append(event.Notes, noteLine.Value)
                }</span>
        }

        <span class="cov5" title="7">return event, nil</span>
}

// ExtractEvents extracts all events from an individual or family record.
// Returns events as structured Event objects.
func ExtractEvents(record Record) []*Event <span class="cov2" title="2">{
        if record == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov2" title="2">events := make([]*Event, 0)

        // Standard event tags
        eventTags := []string{
                "BIRT", "DEAT", "BURI", "CREM", "CHR", "BAPM", "BARM", "BASM",
                "BLES", "CHRA", "CONF", "FCOM", "ORDN", "NATU", "EMIG", "IMMI",
                "CENS", "PROB", "WILL", "GRAD", "RETI", "RESI", "OCCU", "EDUC",
                "MARR", "DIV", "ANUL", "MARB", "MARC", "MARL", "MARS", "ENGA",
                "CAST", "DSCR", "NATI", "PROP", "RELI", "TITL", "EVEN",
        }

        for _, tag := range eventTags </span><span class="cov10" title="78">{
                eventLines := record.GetLines(tag)
                for _, eventLine := range eventLines </span><span class="cov2" title="2">{
                        event, err := ParseEvent(eventLine)
                        if err == nil &amp;&amp; event != nil </span><span class="cov2" title="2">{
                                events = append(events, event)
                        }</span>
                }
        }

        <span class="cov2" title="2">return events</span>
}

// FilterEventsByType filters events by event type.
func FilterEventsByType(events []*Event, eventType EventType) []*Event <span class="cov0" title="0">{
        if events == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">filtered := make([]*Event, 0)
        for _, event := range events </span><span class="cov0" title="0">{
                if event.Type == eventType </span><span class="cov0" title="0">{
                        filtered = append(filtered, event)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

// FilterCustomEvents filters events by custom type name.
func FilterCustomEvents(events []*Event, customType string) []*Event <span class="cov1" title="1">{
        if events == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">filtered := make([]*Event, 0)
        for _, event := range events </span><span class="cov1" title="1">{
                if event.IsCustom() &amp;&amp; event.CustomType == customType </span><span class="cov1" title="1">{
                        filtered = append(filtered, event)
                }</span>
        }
        <span class="cov1" title="1">return filtered</span>
}

</pre>
		
		<pre class="file" id="file9" style="display: none">package types

// EventType represents the type of a GEDCOM event.
// Supports all standard GEDCOM event types plus custom events.
type EventType string

// Standard GEDCOM event types (Individual events)
const (
        EventTypeBirth           EventType = "BIRT" // Birth
        EventTypeDeath           EventType = "DEAT" // Death
        EventTypeBurial          EventType = "BURI" // Burial
        EventTypeCremation       EventType = "CREM" // Cremation
        EventTypeChristening     EventType = "CHR"  // Christening
        EventTypeBaptism         EventType = "BAPM" // Baptism
        EventTypeBarMitzvah      EventType = "BARM" // Bar Mitzvah
        EventTypeBatMitzvah      EventType = "BASM" // Bat Mitzvah
        EventTypeBlessing        EventType = "BLES" // Blessing
        EventTypeAdultChristening EventType = "CHRA" // Adult Christening
        EventTypeConfirmation    EventType = "CONF" // Confirmation
        EventTypeFirstCommunion  EventType = "FCOM" // First Communion
        EventTypeOrdination      EventType = "ORDN" // Ordination
        EventTypeNaturalization  EventType = "NATU" // Naturalization
        EventTypeEmigration      EventType = "EMIG" // Emigration
        EventTypeImmigration     EventType = "IMMI" // Immigration
        EventTypeCensus          EventType = "CENS" // Census
        EventTypeProbate         EventType = "PROB" // Probate
        EventTypeWill            EventType = "WILL" // Will
        EventTypeGraduation      EventType = "GRAD" // Graduation
        EventTypeRetirement      EventType = "RETI" // Retirement
        EventTypeResidence       EventType = "RESI" // Residence
        EventTypeOccupation      EventType = "OCCU" // Occupation
        EventTypeEducation       EventType = "EDUC" // Education
        EventTypeCustom          EventType = "EVEN" // Custom/Generic event (requires TYPE sub-tag)
)

// Family event types
const (
        EventTypeMarriage        EventType = "MARR" // Marriage
        EventTypeDivorce         EventType = "DIV"  // Divorce
        EventTypeAnnulment       EventType = "ANUL" // Annulment
        EventTypeMarriageBann   EventType = "MARB" // Marriage Bann
        EventTypeMarriageContract EventType = "MARC" // Marriage Contract
        EventTypeMarriageLicense EventType = "MARL" // Marriage License
        EventTypeMarriageSettlement EventType = "MARS" // Marriage Settlement
        EventTypeEngagement      EventType = "ENGA" // Engagement
        EventTypeMarriageNotice  EventType = "MARB" // Marriage Notice
)

// Attribute types (also treated as events)
const (
        EventTypeCaste          EventType = "CAST" // Caste
        EventTypeDescription    EventType = "DSCR" // Physical Description
        EventTypeNationality    EventType = "NATI" // Nationality
        EventTypeProperty       EventType = "PROP" // Property
        EventTypeReligion       EventType = "RELI" // Religion
        EventTypeTitle          EventType = "TITL" // Title
)

// IsCustom returns true if this is a custom event type (EVEN with TYPE sub-tag).
func (et EventType) IsCustom() bool <span class="cov7" title="4">{
        return et == EventTypeCustom
}</span>

// String returns the string representation of the event type.
func (et EventType) String() string <span class="cov1" title="1">{
        return string(et)
}</span>

// IsValid returns true if this is a known standard event type.
func (et EventType) IsValid() bool <span class="cov0" title="0">{
        standardTypes := []EventType{
                EventTypeBirth, EventTypeDeath, EventTypeBurial, EventTypeCremation,
                EventTypeChristening, EventTypeBaptism, EventTypeBarMitzvah, EventTypeBatMitzvah,
                EventTypeBlessing, EventTypeAdultChristening, EventTypeConfirmation,
                EventTypeFirstCommunion, EventTypeOrdination, EventTypeNaturalization,
                EventTypeEmigration, EventTypeImmigration, EventTypeCensus, EventTypeProbate,
                EventTypeWill, EventTypeGraduation, EventTypeRetirement, EventTypeResidence,
                EventTypeOccupation, EventTypeEducation, EventTypeCustom,
                EventTypeMarriage, EventTypeDivorce, EventTypeAnnulment, EventTypeMarriageBann,
                EventTypeMarriageContract, EventTypeMarriageLicense, EventTypeMarriageSettlement,
                EventTypeEngagement, EventTypeMarriageNotice,
                EventTypeCaste, EventTypeDescription, EventTypeNationality, EventTypeProperty,
                EventTypeReligion, EventTypeTitle,
        }

        for _, st := range standardTypes </span><span class="cov0" title="0">{
                if et == st </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// ParseEventType parses a string into an EventType.
// For custom events (EVEN), the actual type comes from the TYPE sub-tag.
// This function handles the tag name, not the custom type value.
func ParseEventType(tag string) EventType <span class="cov10" title="7">{
        return EventType(tag)
}</span>

</pre>
		
		<pre class="file" id="file10" style="display: none">package types

import "fmt"

// FamilyRecord represents a Family (FAM) record with domain-specific methods.
type FamilyRecord struct {
        *BaseRecord
}

// NewFamilyRecord creates a new FamilyRecord from a GedcomLine.
func NewFamilyRecord(line *GedcomLine) *FamilyRecord <span class="cov10" title="12">{
        return &amp;FamilyRecord{
                BaseRecord: NewBaseRecord(line),
        }
}</span>

// GetHusband returns the husband's xref (HUSB).
func (fr *FamilyRecord) GetHusband() string <span class="cov1" title="1">{
        return fr.GetValue("HUSB")
}</span>

// GetWife returns the wife's xref (WIFE).
func (fr *FamilyRecord) GetWife() string <span class="cov1" title="1">{
        return fr.GetValue("WIFE")
}</span>

// GetChildren returns all children xrefs (CHIL).
func (fr *FamilyRecord) GetChildren() []string <span class="cov1" title="1">{
        return fr.GetValues("CHIL")
}</span>

// GetMarriageDate returns the marriage date.
func (fr *FamilyRecord) GetMarriageDate() string <span class="cov3" title="2">{
        return fr.GetValue("MARR.DATE")
}</span>

// GetMarriagePlace returns the marriage place.
func (fr *FamilyRecord) GetMarriagePlace() string <span class="cov3" title="2">{
        return fr.GetValue("MARR.PLAC")
}</span>

// GetMarriageData returns a map with marriage date, place, and sources.
func (fr *FamilyRecord) GetMarriageData() map[string]interface{} <span class="cov1" title="1">{
        return map[string]interface{}{
                "date":    fr.GetMarriageDate(),
                "place":   fr.GetMarriagePlace(),
                "sources": fr.GetValues("MARR.SOUR"),
        }
}</span>

// GetDivorceDate returns the divorce date.
func (fr *FamilyRecord) GetDivorceDate() string <span class="cov3" title="2">{
        return fr.GetValue("DIV.DATE")
}</span>

// GetDivorcePlace returns the divorce place.
func (fr *FamilyRecord) GetDivorcePlace() string <span class="cov3" title="2">{
        return fr.GetValue("DIV.PLAC")
}</span>

// GetDivorceData returns a map with divorce date, place, and sources.
func (fr *FamilyRecord) GetDivorceData() map[string]interface{} <span class="cov1" title="1">{
        return map[string]interface{}{
                "date":    fr.GetDivorceDate(),
                "place":   fr.GetDivorcePlace(),
                "sources": fr.GetValues("DIV.SOUR"),
        }
}</span>

// GetEvents returns all family event records (MARR, DIV, ANUL, etc.).
func (fr *FamilyRecord) GetEvents() []map[string]interface{} <span class="cov1" title="1">{
        eventTags := []string{"MARR", "DIV", "ANUL", "CENS", "DIVF", "ENGA", "MARB", "MARC", "MARL", "MARS"}
        return extractEvents(fr, eventTags)
}</span>

// GetNotes returns all note xrefs.
// Delegates to BaseRecord.GetNotes().
func (fr *FamilyRecord) GetNotes() []string <span class="cov1" title="1">{
        return fr.BaseRecord.GetNotes()
}</span>

// GetSources returns all source xrefs.
// Delegates to BaseRecord.GetSources().
func (fr *FamilyRecord) GetSources() []string <span class="cov1" title="1">{
        return fr.BaseRecord.GetSources()
}</span>

// GetMarriageDateParsed returns the marriage date as a parsed GedcomDate.
// Returns error if date string is empty or cannot be parsed.
func (fr *FamilyRecord) GetMarriageDateParsed() (*GedcomDate, error) <span class="cov1" title="1">{
        dateStr := fr.GetMarriageDate()
        if dateStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no marriage date found")
        }</span>
        <span class="cov1" title="1">return ParseDate(dateStr)</span>
}

// GetDivorceDateParsed returns the divorce date as a parsed GedcomDate.
// Returns error if date string is empty or cannot be parsed.
func (fr *FamilyRecord) GetDivorceDateParsed() (*GedcomDate, error) <span class="cov0" title="0">{
        dateStr := fr.GetDivorceDate()
        if dateStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no divorce date found")
        }</span>
        <span class="cov0" title="0">return ParseDate(dateStr)</span>
}

// GetMarriagePlaceParsed returns the marriage place as a parsed GedcomPlace.
// Returns error if place string is empty or cannot be parsed.
func (fr *FamilyRecord) GetMarriagePlaceParsed() (*GedcomPlace, error) <span class="cov1" title="1">{
        placeStr := fr.GetMarriagePlace()
        if placeStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no marriage place found")
        }</span>
        <span class="cov1" title="1">return ParsePlace(placeStr)</span>
}

// GetDivorcePlaceParsed returns the divorce place as a parsed GedcomPlace.
// Returns error if place string is empty or cannot be parsed.
func (fr *FamilyRecord) GetDivorcePlaceParsed() (*GedcomPlace, error) <span class="cov0" title="0">{
        placeStr := fr.GetDivorcePlace()
        if placeStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no divorce place found")
        }</span>
        <span class="cov0" title="0">return ParsePlace(placeStr)</span>
}

// ============================================================================
// Phase 2: Enhanced FamilyRecord Relationship Methods
// ============================================================================

// GetHusbandRecord returns the husband's IndividualRecord.
// Returns nil if no husband is specified or the husband record is not found.
// Returns an error if the record is not part of a tree.
func (fr *FamilyRecord) GetHusbandRecord() (*IndividualRecord, error) <span class="cov0" title="0">{
        husbandXref := fr.GetHusband()
        if husbandXref == "" </span><span class="cov0" title="0">{
                return nil, nil // No husband, but not an error
        }</span>

        <span class="cov0" title="0">tree := fr.getTree()
        if tree == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("family record is not part of a tree")
        }</span>

        <span class="cov0" title="0">husbandRecord := tree.GetIndividual(husbandXref)
        if husbandRecord == nil </span><span class="cov0" title="0">{
                return nil, nil // Husband not found, but not an error
        }</span>

        <span class="cov0" title="0">husband, ok := husbandRecord.(*IndividualRecord)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("husband record %s is not an IndividualRecord", husbandXref)
        }</span>

        <span class="cov0" title="0">return husband, nil</span>
}

// GetWifeRecord returns the wife's IndividualRecord.
// Returns nil if no wife is specified or the wife record is not found.
// Returns an error if the record is not part of a tree.
func (fr *FamilyRecord) GetWifeRecord() (*IndividualRecord, error) <span class="cov0" title="0">{
        wifeXref := fr.GetWife()
        if wifeXref == "" </span><span class="cov0" title="0">{
                return nil, nil // No wife, but not an error
        }</span>

        <span class="cov0" title="0">tree := fr.getTree()
        if tree == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("family record is not part of a tree")
        }</span>

        <span class="cov0" title="0">wifeRecord := tree.GetIndividual(wifeXref)
        if wifeRecord == nil </span><span class="cov0" title="0">{
                return nil, nil // Wife not found, but not an error
        }</span>

        <span class="cov0" title="0">wife, ok := wifeRecord.(*IndividualRecord)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wife record %s is not an IndividualRecord", wifeXref)
        }</span>

        <span class="cov0" title="0">return wife, nil</span>
}

// GetChildrenRecords returns all children's IndividualRecords.
// Returns an empty slice if no children are specified or children records are not found.
// Returns an error if the record is not part of a tree.
func (fr *FamilyRecord) GetChildrenRecords() ([]*IndividualRecord, error) <span class="cov0" title="0">{
        childXrefs := fr.GetChildren()
        if len(childXrefs) == 0 </span><span class="cov0" title="0">{
                return []*IndividualRecord{}, nil
        }</span>

        <span class="cov0" title="0">tree := fr.getTree()
        if tree == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("family record is not part of a tree")
        }</span>

        <span class="cov0" title="0">children := make([]*IndividualRecord, 0, len(childXrefs))
        for _, childXref := range childXrefs </span><span class="cov0" title="0">{
                childRecord := tree.GetIndividual(childXref)
                if childRecord == nil </span><span class="cov0" title="0">{
                        continue</span> // Skip missing children
                }

                <span class="cov0" title="0">child, ok := childRecord.(*IndividualRecord)
                if !ok </span><span class="cov0" title="0">{
                        continue</span> // Skip non-individual records
                }

                <span class="cov0" title="0">children = append(children, child)</span>
        }

        <span class="cov0" title="0">return children, nil</span>
}

// GetSpouses returns both husband and wife as IndividualRecords.
// Returns an empty slice if neither spouse is specified.
// Returns an error if the record is not part of a tree.
func (fr *FamilyRecord) GetSpouses() ([]*IndividualRecord, error) <span class="cov0" title="0">{
        spouses := make([]*IndividualRecord, 0, 2)

        husband, err := fr.GetHusbandRecord()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if husband != nil </span><span class="cov0" title="0">{
                spouses = append(spouses, husband)
        }</span>

        <span class="cov0" title="0">wife, err := fr.GetWifeRecord()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if wife != nil </span><span class="cov0" title="0">{
                spouses = append(spouses, wife)
        }</span>

        <span class="cov0" title="0">return spouses, nil</span>
}

// HasChild checks if the specified individual is a child of this family.
// Returns an error if the record is not part of a tree.
func (fr *FamilyRecord) HasChild(individual *IndividualRecord) bool <span class="cov0" title="0">{
        if individual == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">childXrefs := fr.GetChildren()
        for _, childXref := range childXrefs </span><span class="cov0" title="0">{
                if childXref == individual.XrefID() </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package types

// HeaderRecord represents a Header (HEAD) record with metadata methods.
type HeaderRecord struct {
        *BaseRecord
}

// NewHeaderRecord creates a new HeaderRecord from a GedcomLine.
func NewHeaderRecord(line *GedcomLine) *HeaderRecord <span class="cov10" title="3">{
        return &amp;HeaderRecord{
                BaseRecord: NewBaseRecord(line),
        }
}</span>

// GetGedcomVersion returns the GEDCOM version (GEDC.VERS).
func (hr *HeaderRecord) GetGedcomVersion() string <span class="cov1" title="1">{
        return hr.GetValue("GEDC.VERS")
}</span>

// GetGedcomForm returns the GEDCOM form (GEDC.FORM).
func (hr *HeaderRecord) GetGedcomForm() string <span class="cov1" title="1">{
        return hr.GetValue("GEDC.FORM")
}</span>

// GetCharacterEncoding returns the character encoding (CHAR).
func (hr *HeaderRecord) GetCharacterEncoding() string <span class="cov1" title="1">{
        return hr.GetValue("CHAR")
}</span>

// GetSourceName returns the source name (SOUR.NAME).
func (hr *HeaderRecord) GetSourceName() string <span class="cov1" title="1">{
        return hr.GetValue("SOUR.NAME")
}</span>

// GetSourceVersion returns the source version (SOUR.VERS).
func (hr *HeaderRecord) GetSourceVersion() string <span class="cov1" title="1">{
        return hr.GetValue("SOUR.VERS")
}</span>

// GetSourceCorporation returns the source corporation (SOUR.CORP).
func (hr *HeaderRecord) GetSourceCorporation() string <span class="cov1" title="1">{
        return hr.GetValue("SOUR.CORP")
}</span>

// GetSubmissionXref returns the submitter xref (SUBM).
func (hr *HeaderRecord) GetSubmissionXref() string <span class="cov1" title="1">{
        return hr.GetValue("SUBM")
}</span>

// GetFile returns the file name (FILE).
func (hr *HeaderRecord) GetFile() string <span class="cov1" title="1">{
        return hr.GetValue("FILE")
}</span>

// GetLanguage returns the language (LANG).
func (hr *HeaderRecord) GetLanguage() string <span class="cov1" title="1">{
        return hr.GetValue("LANG")
}</span>

// GetDate returns the header date (DATE).
func (hr *HeaderRecord) GetDate() string <span class="cov1" title="1">{
        return hr.GetValue("DATE")
}</span>



</pre>
		
		<pre class="file" id="file12" style="display: none">package types

import "fmt"

// IndividualRecord represents an Individual (INDI) record with domain-specific methods.
type IndividualRecord struct {
        *BaseRecord
}

// NewIndividualRecord creates a new IndividualRecord from a GedcomLine.
func NewIndividualRecord(line *GedcomLine) *IndividualRecord <span class="cov10" title="33">{
        return &amp;IndividualRecord{
                BaseRecord: NewBaseRecord(line),
        }
}</span>

// GetName returns the primary name value.
// Returns the first NAME value found.
func (ir *IndividualRecord) GetName() string <span class="cov1" title="1">{
        return ir.GetValue("NAME")
}</span>

// GetNames returns all name values (multiple NAME tags allowed).
func (ir *IndividualRecord) GetNames() []string <span class="cov1" title="1">{
        return ir.GetValues("NAME")
}</span>

// GetGivenName returns the given name from the first NAME record.
func (ir *IndividualRecord) GetGivenName() string <span class="cov1" title="1">{
        return ir.GetValue("NAME.GIVN")
}</span>

// GetSurname returns the surname from the first NAME record.
func (ir *IndividualRecord) GetSurname() string <span class="cov1" title="1">{
        return ir.GetValue("NAME.SURN")
}</span>

// GetSex returns the sex value (M, F, U, etc.).
func (ir *IndividualRecord) GetSex() string <span class="cov1" title="1">{
        return ir.GetValue("SEX")
}</span>

// GetBirthDate returns the birth date.
func (ir *IndividualRecord) GetBirthDate() string <span class="cov2" title="2">{
        return ir.GetValue("BIRT.DATE")
}</span>

// GetBirthPlace returns the birth place.
func (ir *IndividualRecord) GetBirthPlace() string <span class="cov2" title="2">{
        return ir.GetValue("BIRT.PLAC")
}</span>

// GetDeathDate returns the death date.
func (ir *IndividualRecord) GetDeathDate() string <span class="cov2" title="2">{
        return ir.GetValue("DEAT.DATE")
}</span>

// GetDeathPlace returns the death place.
func (ir *IndividualRecord) GetDeathPlace() string <span class="cov2" title="2">{
        return ir.GetValue("DEAT.PLAC")
}</span>

// GetBirthData returns a map with birth date, place, and sources.
func (ir *IndividualRecord) GetBirthData() map[string]interface{} <span class="cov1" title="1">{
        return map[string]interface{}{
                "date":    ir.GetBirthDate(),
                "place":   ir.GetBirthPlace(),
                "sources": ir.GetValues("BIRT.SOUR"),
        }
}</span>

// GetDeathData returns a map with death date, place, and sources.
func (ir *IndividualRecord) GetDeathData() map[string]interface{} <span class="cov1" title="1">{
        return map[string]interface{}{
                "date":    ir.GetDeathDate(),
                "place":   ir.GetDeathPlace(),
                "sources": ir.GetValues("DEAT.SOUR"),
        }
}</span>

// GetFamiliesAsSpouse returns all family xrefs where this individual is a spouse (FAMS).
func (ir *IndividualRecord) GetFamiliesAsSpouse() []string <span class="cov1" title="1">{
        return ir.GetValues("FAMS")
}</span>

// GetFamiliesAsChild returns all family xrefs where this individual is a child (FAMC).
func (ir *IndividualRecord) GetFamiliesAsChild() []string <span class="cov1" title="1">{
        return ir.GetValues("FAMC")
}</span>

// GetOccupation returns the occupation value.
func (ir *IndividualRecord) GetOccupation() string <span class="cov1" title="1">{
        return ir.GetValue("OCCU")
}</span>

// GetEvents returns all event records (BIRT, DEAT, MARR, etc.).
// Returns a slice of maps with type, date, place, and description.
func (ir *IndividualRecord) GetEvents() []map[string]interface{} <span class="cov1" title="1">{
        eventTags := []string{"BIRT", "DEAT", "BURI", "CREM", "CHR", "BAPM", "BARM", "BASM",
                "BLES", "CHRA", "CONF", "FCOM", "ORDN", "NATU", "EMIG", "IMMI", "CENS",
                "PROB", "WILL", "GRAD", "RETI", "EVEN", "MARR", "DIV", "RESI", "OCCU", "EDUC"}
        return extractEvents(ir, eventTags)
}</span>

// GetAttributes returns all attribute records (CAST, DSCR, EDUC, NATI, OCCU, PROP, RELI, RESI, TITL).
func (ir *IndividualRecord) GetAttributes() []map[string]interface{} <span class="cov1" title="1">{
        attributeTags := []string{"CAST", "DSCR", "EDUC", "NATI", "OCCU", "PROP", "RELI", "RESI", "TITL"}

        attributes := make([]map[string]interface{}, 0)
        for _, tag := range attributeTags </span><span class="cov6" title="9">{
                attributeLines := ir.GetLines(tag)
                for _, line := range attributeLines </span><span class="cov1" title="1">{
                        attribute := map[string]interface{}{
                                "type":  tag,
                                "value": line.Value,
                                "date":  line.GetValue("DATE"),
                                "place": line.GetValue("PLAC"),
                        }
                        attributes = append(attributes, attribute)
                }</span>
        }
        <span class="cov1" title="1">return attributes</span>
}

// GetNotes returns all note xrefs.
// Delegates to BaseRecord.GetNotes().
func (ir *IndividualRecord) GetNotes() []string <span class="cov1" title="1">{
        return ir.BaseRecord.GetNotes()
}</span>

// GetSources returns all source xrefs.
// Delegates to BaseRecord.GetSources().
func (ir *IndividualRecord) GetSources() []string <span class="cov1" title="1">{
        return ir.BaseRecord.GetSources()
}</span>

// GetBirthDateParsed returns the birth date as a parsed GedcomDate.
// Returns error if date string is empty or cannot be parsed.
func (ir *IndividualRecord) GetBirthDateParsed() (*GedcomDate, error) <span class="cov1" title="1">{
        dateStr := ir.GetBirthDate()
        if dateStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no birth date found")
        }</span>
        <span class="cov1" title="1">return ParseDate(dateStr)</span>
}

// GetDeathDateParsed returns the death date as a parsed GedcomDate.
// Returns error if date string is empty or cannot be parsed.
func (ir *IndividualRecord) GetDeathDateParsed() (*GedcomDate, error) <span class="cov0" title="0">{
        dateStr := ir.GetDeathDate()
        if dateStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no death date found")
        }</span>
        <span class="cov0" title="0">return ParseDate(dateStr)</span>
}

// GetBirthPlaceParsed returns the birth place as a parsed GedcomPlace.
// Returns error if place string is empty or cannot be parsed.
func (ir *IndividualRecord) GetBirthPlaceParsed() (*GedcomPlace, error) <span class="cov1" title="1">{
        placeStr := ir.GetBirthPlace()
        if placeStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no birth place found")
        }</span>
        <span class="cov1" title="1">return ParsePlace(placeStr)</span>
}

// GetDeathPlaceParsed returns the death place as a parsed GedcomPlace.
// Returns error if place string is empty or cannot be parsed.
func (ir *IndividualRecord) GetDeathPlaceParsed() (*GedcomPlace, error) <span class="cov0" title="0">{
        placeStr := ir.GetDeathPlace()
        if placeStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no death place found")
        }</span>
        <span class="cov0" title="0">return ParsePlace(placeStr)</span>
}

// GetNamesParsed returns all names as parsed GedcomName objects.
// Supports multiple NAME records per individual (GEDCOM 5.5.1).
// Returns empty slice if no names found.
func (ir *IndividualRecord) GetNamesParsed() ([]*GedcomName, error) <span class="cov6" title="8">{
        nameLines := ir.GetLines("NAME")
        if len(nameLines) == 0 </span><span class="cov0" title="0">{
                return []*GedcomName{}, nil
        }</span>

        <span class="cov6" title="8">names := make([]*GedcomName, 0, len(nameLines))
        for _, nameLine := range nameLines </span><span class="cov7" title="12">{
                name, err := ParseName(nameLine)
                if err != nil </span><span class="cov0" title="0">{
                        // Continue parsing other names even if one fails
                        continue</span>
                }
                <span class="cov7" title="12">if name != nil </span><span class="cov7" title="12">{
                        names = append(names, name)
                }</span>
        }

        <span class="cov6" title="8">return names, nil</span>
}

// GetPrimaryName returns the first (primary) name as a parsed GedcomName.
// Returns nil if no names found.
func (ir *IndividualRecord) GetPrimaryName() (*GedcomName, error) <span class="cov3" title="3">{
        nameLines := ir.GetLines("NAME")
        if len(nameLines) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no name found")
        }</span>

        <span class="cov2" title="2">return ParseName(nameLines[0])</span>
}

// GetNameByType returns a name of the specified type.
// Returns nil if no name of that type is found.
func (ir *IndividualRecord) GetNameByType(nameType NameType) (*GedcomName, error) <span class="cov6" title="7">{
        names, err := ir.GetNamesParsed()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="7">for _, name := range names </span><span class="cov6" title="9">{
                if name.Type == nameType </span><span class="cov4" title="4">{
                        return name, nil
                }</span>
        }

        <span class="cov3" title="3">return nil, fmt.Errorf("no name of type %s found", nameType)</span>
}

// GetBirthName returns the birth name (TYPE birth) if available.
// Falls back to primary name if no birth name is found.
func (ir *IndividualRecord) GetBirthName() (*GedcomName, error) <span class="cov2" title="2">{
        birthName, err := ir.GetNameByType(NameTypeBirth)
        if err == nil &amp;&amp; birthName != nil </span><span class="cov1" title="1">{
                return birthName, nil
        }</span>

        // Fallback to primary name
        <span class="cov1" title="1">return ir.GetPrimaryName()</span>
}

// GetMarriedName returns the married name (TYPE married) if available.
// Returns nil if no married name is found.
func (ir *IndividualRecord) GetMarriedName() (*GedcomName, error) <span class="cov2" title="2">{
        return ir.GetNameByType(NameTypeMarried)
}</span>

// ============================================================================
// Structured Node Methods (Hybrid Approach)
// These methods return structured node types similar to elliotchance,
// while keeping the existing string-based methods above.
// ============================================================================

// Name returns the primary name as a structured NameNode.
// Returns nil if no name is found.
func (ir *IndividualRecord) Name() *NameNode <span class="cov1" title="1">{
        nameLines := ir.GetLines("NAME")
        if len(nameLines) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">return NewNameNodeFromLine(nameLines[0])</span>
}

// Names returns all names as structured NameNodes.
// Returns empty slice if no names found.
func (ir *IndividualRecord) Names() []*NameNode <span class="cov0" title="0">{
        nameLines := ir.GetLines("NAME")
        if len(nameLines) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">names := make([]*NameNode, 0, len(nameLines))
        for _, nameLine := range nameLines </span><span class="cov0" title="0">{
                if nameNode := NewNameNodeFromLine(nameLine); nameNode != nil </span><span class="cov0" title="0">{
                        names = append(names, nameNode)
                }</span>
        }
        <span class="cov0" title="0">return names</span>
}

// Birth returns the birth event as a structured Event.
// Returns nil if no birth event is found.
func (ir *IndividualRecord) Birth() *Event <span class="cov3" title="3">{
        birthLines := ir.GetLines("BIRT")
        if len(birthLines) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov3" title="3">event, err := ParseEvent(birthLines[0])
        if err != nil || event == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov3" title="3">return event</span>
}

// Death returns the death event as a structured Event.
// Returns nil if no death event is found.
func (ir *IndividualRecord) Death() *Event <span class="cov0" title="0">{
        deathLines := ir.GetLines("DEAT")
        if len(deathLines) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">event, err := ParseEvent(deathLines[0])
        if err != nil || event == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return event</span>
}

// Births returns all birth events as structured Events.
// Returns empty slice if no birth events found.
func (ir *IndividualRecord) Births() []*Event <span class="cov0" title="0">{
        return FilterEventsByType(ExtractEvents(ir), EventTypeBirth)
}</span>

// Deaths returns all death events as structured Events.
// Returns empty slice if no death events found.
func (ir *IndividualRecord) Deaths() []*Event <span class="cov0" title="0">{
        return FilterEventsByType(ExtractEvents(ir), EventTypeDeath)
}</span>

// Events returns all events as structured Events.
// Includes standard events (BIRT, DEAT, etc.) and custom events (EVEN).
func (ir *IndividualRecord) Events() []*Event <span class="cov0" title="0">{
        return ExtractEvents(ir)
}</span>

// EventsByType returns all events of the specified type.
// For custom events, use FilterCustomEvents instead.
func (ir *IndividualRecord) EventsByType(eventType EventType) []*Event <span class="cov0" title="0">{
        return FilterEventsByType(ExtractEvents(ir), eventType)
}</span>

// CustomEvents returns all custom events (EVEN tags).
func (ir *IndividualRecord) CustomEvents() []*Event <span class="cov1" title="1">{
        events := ExtractEvents(ir)
        custom := make([]*Event, 0)
        for _, event := range events </span><span class="cov1" title="1">{
                if event.IsCustom() </span><span class="cov1" title="1">{
                        custom = append(custom, event)
                }</span>
        }
        <span class="cov1" title="1">return custom</span>
}

// CustomEventsByType returns custom events with the specified custom type name.
func (ir *IndividualRecord) CustomEventsByType(customType string) []*Event <span class="cov1" title="1">{
        return FilterCustomEvents(ExtractEvents(ir), customType)
}</span>

// Baptism returns the baptism event as a structured Event.
func (ir *IndividualRecord) Baptism() *Event <span class="cov0" title="0">{
        baptismLines := ir.GetLines("BAPM")
        if len(baptismLines) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">event, err := ParseEvent(baptismLines[0])
        if err != nil || event == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return event</span>
}

// Burial returns the burial event as a structured Event.
func (ir *IndividualRecord) Burial() *Event <span class="cov0" title="0">{
        burialLines := ir.GetLines("BURI")
        if len(burialLines) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">event, err := ParseEvent(burialLines[0])
        if err != nil || event == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return event</span>
}

// Baptisms returns all baptism events.
func (ir *IndividualRecord) Baptisms() []*Event <span class="cov0" title="0">{
        return FilterEventsByType(ExtractEvents(ir), EventTypeBaptism)
}</span>

// Burials returns all burial events.
func (ir *IndividualRecord) Burials() []*Event <span class="cov0" title="0">{
        return FilterEventsByType(ExtractEvents(ir), EventTypeBurial)
}</span>

// BirthDate returns the birth date as a structured DateNode.
// Returns nil if no birth date is found.
func (ir *IndividualRecord) BirthDate() *DateNode <span class="cov1" title="1">{
        birth := ir.Birth()
        if birth == nil || birth.Date == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">return birth.Date</span>
}

// DeathDate returns the death date as a structured DateNode.
// Returns nil if no death date is found.
func (ir *IndividualRecord) DeathDate() *DateNode <span class="cov0" title="0">{
        death := ir.Death()
        if death == nil || death.Date == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return death.Date</span>
}

// BirthPlace returns the birth place as a structured PlaceNode.
// Returns nil if no birth place is found.
func (ir *IndividualRecord) BirthPlace() *PlaceNode <span class="cov1" title="1">{
        birth := ir.Birth()
        if birth == nil || birth.Place == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">return birth.Place</span>
}

// DeathPlace returns the death place as a structured PlaceNode.
// Returns nil if no death place is found.
func (ir *IndividualRecord) DeathPlace() *PlaceNode <span class="cov0" title="0">{
        death := ir.Death()
        if death == nil || death.Place == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return death.Place</span>
}

// ============================================================================
// Phase 1: Direct Relationship Methods
// ============================================================================

// Spouses returns all spouses of this individual.
// Traverses families directly without requiring the query package.
// Returns an error if the record is not part of a tree.
func (ir *IndividualRecord) Spouses() ([]*IndividualRecord, error) <span class="cov0" title="0">{
        tree := ir.getTree()
        if tree == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("individual record is not part of a tree")
        }</span>

        // Get all families where this individual is a spouse
        <span class="cov0" title="0">famXrefs := ir.GetFamiliesAsSpouse()
        spouseMap := make(map[string]*IndividualRecord)

        for _, famXref := range famXrefs </span><span class="cov0" title="0">{
                famRecord := tree.GetFamily(famXref)
                if famRecord == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fr, ok := famRecord.(*FamilyRecord)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">husbandXref := fr.GetHusband()
                wifeXref := fr.GetWife()

                // If this individual is the husband, get the wife
                if ir.XrefID() == husbandXref &amp;&amp; wifeXref != "" </span><span class="cov0" title="0">{
                        if spouseRecord := tree.GetIndividual(wifeXref); spouseRecord != nil </span><span class="cov0" title="0">{
                                if spouse, ok := spouseRecord.(*IndividualRecord); ok </span><span class="cov0" title="0">{
                                        spouseMap[wifeXref] = spouse
                                }</span>
                        }
                }

                // If this individual is the wife, get the husband
                <span class="cov0" title="0">if ir.XrefID() == wifeXref &amp;&amp; husbandXref != "" </span><span class="cov0" title="0">{
                        if spouseRecord := tree.GetIndividual(husbandXref); spouseRecord != nil </span><span class="cov0" title="0">{
                                if spouse, ok := spouseRecord.(*IndividualRecord); ok </span><span class="cov0" title="0">{
                                        spouseMap[husbandXref] = spouse
                                }</span>
                        }
                }
        }

        // Convert map to slice
        <span class="cov0" title="0">spouses := make([]*IndividualRecord, 0, len(spouseMap))
        for _, spouse := range spouseMap </span><span class="cov0" title="0">{
                spouses = append(spouses, spouse)
        }</span>

        <span class="cov0" title="0">return spouses, nil</span>
}

// Children returns all children of this individual.
// Traverses families directly without requiring the query package.
// Returns an error if the record is not part of a tree.
func (ir *IndividualRecord) Children() ([]*IndividualRecord, error) <span class="cov0" title="0">{
        tree := ir.getTree()
        if tree == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("individual record is not part of a tree")
        }</span>

        // Get all families where this individual is a spouse (not a child)
        <span class="cov0" title="0">famXrefs := ir.GetFamiliesAsSpouse()
        childMap := make(map[string]*IndividualRecord)

        for _, famXref := range famXrefs </span><span class="cov0" title="0">{
                famRecord := tree.GetFamily(famXref)
                if famRecord == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fr, ok := famRecord.(*FamilyRecord)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get children from this family
                <span class="cov0" title="0">childXrefs := fr.GetChildren()
                for _, childXref := range childXrefs </span><span class="cov0" title="0">{
                        if childRecord := tree.GetIndividual(childXref); childRecord != nil </span><span class="cov0" title="0">{
                                if child, ok := childRecord.(*IndividualRecord); ok </span><span class="cov0" title="0">{
                                        childMap[childXref] = child
                                }</span>
                        }
                }
        }

        // Convert map to slice
        <span class="cov0" title="0">children := make([]*IndividualRecord, 0, len(childMap))
        for _, child := range childMap </span><span class="cov0" title="0">{
                children = append(children, child)
        }</span>

        <span class="cov0" title="0">return children, nil</span>
}

// Parents returns all parents of this individual.
// Traverses families directly without requiring the query package.
// Returns an error if the record is not part of a tree.
func (ir *IndividualRecord) Parents() ([]*IndividualRecord, error) <span class="cov0" title="0">{
        tree := ir.getTree()
        if tree == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("individual record is not part of a tree")
        }</span>

        // Get all families where this individual is a child
        <span class="cov0" title="0">famXrefs := ir.GetFamiliesAsChild()
        parentMap := make(map[string]*IndividualRecord)

        for _, famXref := range famXrefs </span><span class="cov0" title="0">{
                famRecord := tree.GetFamily(famXref)
                if famRecord == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fr, ok := famRecord.(*FamilyRecord)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get husband (father)
                <span class="cov0" title="0">husbandXref := fr.GetHusband()
                if husbandXref != "" </span><span class="cov0" title="0">{
                        if husbandRecord := tree.GetIndividual(husbandXref); husbandRecord != nil </span><span class="cov0" title="0">{
                                if husband, ok := husbandRecord.(*IndividualRecord); ok </span><span class="cov0" title="0">{
                                        parentMap[husbandXref] = husband
                                }</span>
                        }
                }

                // Get wife (mother)
                <span class="cov0" title="0">wifeXref := fr.GetWife()
                if wifeXref != "" </span><span class="cov0" title="0">{
                        if wifeRecord := tree.GetIndividual(wifeXref); wifeRecord != nil </span><span class="cov0" title="0">{
                                if wife, ok := wifeRecord.(*IndividualRecord); ok </span><span class="cov0" title="0">{
                                        parentMap[wifeXref] = wife
                                }</span>
                        }
                }
        }

        // Convert map to slice
        <span class="cov0" title="0">parents := make([]*IndividualRecord, 0, len(parentMap))
        for _, parent := range parentMap </span><span class="cov0" title="0">{
                parents = append(parents, parent)
        }</span>

        <span class="cov0" title="0">return parents, nil</span>
}

// Siblings returns all siblings of this individual.
// Traverses families directly without requiring the query package.
// Returns an error if the record is not part of a tree.
func (ir *IndividualRecord) Siblings() ([]*IndividualRecord, error) <span class="cov0" title="0">{
        tree := ir.getTree()
        if tree == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("individual record is not part of a tree")
        }</span>

        // Get all families where this individual is a child
        <span class="cov0" title="0">famXrefs := ir.GetFamiliesAsChild()
        siblingMap := make(map[string]*IndividualRecord)

        for _, famXref := range famXrefs </span><span class="cov0" title="0">{
                famRecord := tree.GetFamily(famXref)
                if famRecord == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fr, ok := famRecord.(*FamilyRecord)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get all children from this family (excluding self)
                <span class="cov0" title="0">childXrefs := fr.GetChildren()
                for _, childXref := range childXrefs </span><span class="cov0" title="0">{
                        if childXref == ir.XrefID() </span><span class="cov0" title="0">{
                                continue</span> // Skip self
                        }

                        <span class="cov0" title="0">if childRecord := tree.GetIndividual(childXref); childRecord != nil </span><span class="cov0" title="0">{
                                if sibling, ok := childRecord.(*IndividualRecord); ok </span><span class="cov0" title="0">{
                                        siblingMap[childXref] = sibling
                                }</span>
                        }
                }
        }

        // Convert map to slice
        <span class="cov0" title="0">siblings := make([]*IndividualRecord, 0, len(siblingMap))
        for _, sibling := range siblingMap </span><span class="cov0" title="0">{
                siblings = append(siblings, sibling)
        }</span>

        <span class="cov0" title="0">return siblings, nil</span>
}

// Families returns all families this individual is part of (as spouse OR child).
// Traverses families directly without requiring the query package.
// Returns an error if the record is not part of a tree.
func (ir *IndividualRecord) Families() ([]*FamilyRecord, error) <span class="cov0" title="0">{
        tree := ir.getTree()
        if tree == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("individual record is not part of a tree")
        }</span>

        // Get families as spouse and as child
        <span class="cov0" title="0">famsAsSpouse := ir.GetFamiliesAsSpouse()
        famsAsChild := ir.GetFamiliesAsChild()

        // Combine and deduplicate
        famXrefs := make(map[string]bool)
        for _, xref := range famsAsSpouse </span><span class="cov0" title="0">{
                famXrefs[xref] = true
        }</span>
        <span class="cov0" title="0">for _, xref := range famsAsChild </span><span class="cov0" title="0">{
                famXrefs[xref] = true
        }</span>

        // Convert to FamilyRecord slice
        <span class="cov0" title="0">families := make([]*FamilyRecord, 0, len(famXrefs))
        for xref := range famXrefs </span><span class="cov0" title="0">{
                record := tree.GetFamily(xref)
                if fr, ok := record.(*FamilyRecord); ok </span><span class="cov0" title="0">{
                        families = append(families, fr)
                }</span>
        }

        <span class="cov0" title="0">return families, nil</span>
}

// ============================================================================
// Phase 2: Family Lookup Methods
// ============================================================================

// FamilyWithSpouse finds the family record where this individual is married to the specified spouse.
// Returns nil if no such family exists.
// Returns an error if the record is not part of a tree.
func (ir *IndividualRecord) FamilyWithSpouse(spouse *IndividualRecord) (*FamilyRecord, error) <span class="cov0" title="0">{
        if spouse == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("spouse cannot be nil")
        }</span>

        <span class="cov0" title="0">tree := ir.getTree()
        if tree == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("individual record is not part of a tree")
        }</span>

        // Get all families where this individual is a spouse
        <span class="cov0" title="0">famXrefs := ir.GetFamiliesAsSpouse()
        for _, famXref := range famXrefs </span><span class="cov0" title="0">{
                famRecord := tree.GetFamily(famXref)
                if famRecord == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fr, ok := famRecord.(*FamilyRecord)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if the spouse matches
                <span class="cov0" title="0">husbandXref := fr.GetHusband()
                wifeXref := fr.GetWife()

                // Check if this individual is husband and spouse is wife, or vice versa
                if (ir.XrefID() == husbandXref &amp;&amp; spouse.XrefID() == wifeXref) ||
                        (ir.XrefID() == wifeXref &amp;&amp; spouse.XrefID() == husbandXref) </span><span class="cov0" title="0">{
                        return fr, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, nil</span> // No family found, but not an error
}

// FamilyWithUnknownSpouse finds a family record where this individual is a spouse
// but the other spouse is unknown (nil).
// Returns nil if no such family exists.
// Returns an error if the record is not part of a tree.
func (ir *IndividualRecord) FamilyWithUnknownSpouse() (*FamilyRecord, error) <span class="cov0" title="0">{
        tree := ir.getTree()
        if tree == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("individual record is not part of a tree")
        }</span>

        // Get all families where this individual is a spouse
        <span class="cov0" title="0">famXrefs := ir.GetFamiliesAsSpouse()
        for _, famXref := range famXrefs </span><span class="cov0" title="0">{
                famRecord := tree.GetFamily(famXref)
                if famRecord == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fr, ok := famRecord.(*FamilyRecord)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">husbandXref := fr.GetHusband()
                wifeXref := fr.GetWife()

                // Check if this individual is husband and wife is missing, or vice versa
                if (ir.XrefID() == husbandXref &amp;&amp; wifeXref == "") ||
                        (ir.XrefID() == wifeXref &amp;&amp; husbandXref == "") </span><span class="cov0" title="0">{
                        return fr, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, nil</span> // No family found, but not an error
}

// ============================================================================
// Phase 3: SpouseChildren Pattern
// ============================================================================

// SpouseChildren maps each known spouse to their children with that spouse.
// The map key is the spouse (nil if the spouse is unknown).
// Children can appear under multiple spouses if they are shared.
// Returns an error if the record is not part of a tree or graph building fails.
func (ir *IndividualRecord) SpouseChildren() (map[*IndividualRecord][]*IndividualRecord, error) <span class="cov0" title="0">{
        tree := ir.getTree()
        if tree == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("individual record is not part of a tree")
        }</span>

        // No graph needed - traverse families directly

        // Get all families where this individual is a spouse (not a child)
        <span class="cov0" title="0">famXrefs := ir.GetFamiliesAsSpouse()
        spouseChildren := make(map[*IndividualRecord][]*IndividualRecord)

        for _, famXref := range famXrefs </span><span class="cov0" title="0">{
                famRecord := tree.GetFamily(famXref)
                if famRecord == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fr, ok := famRecord.(*FamilyRecord)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get the other spouse
                <span class="cov0" title="0">var spouse *IndividualRecord
                husbandXref := fr.GetHusband()
                wifeXref := fr.GetWife()

                if ir.XrefID() == husbandXref </span><span class="cov0" title="0">{
                        // This individual is the husband, get the wife
                        if wifeXref != "" </span><span class="cov0" title="0">{
                                spouseRecord := tree.GetIndividual(wifeXref)
                                if spouseIndi, ok := spouseRecord.(*IndividualRecord); ok </span><span class="cov0" title="0">{
                                        spouse = spouseIndi
                                }</span>
                        }
                } else<span class="cov0" title="0"> if ir.XrefID() == wifeXref </span><span class="cov0" title="0">{
                        // This individual is the wife, get the husband
                        if husbandXref != "" </span><span class="cov0" title="0">{
                                spouseRecord := tree.GetIndividual(husbandXref)
                                if spouseIndi, ok := spouseRecord.(*IndividualRecord); ok </span><span class="cov0" title="0">{
                                        spouse = spouseIndi
                                }</span>
                        }
                }

                // Get children from this family
                <span class="cov0" title="0">childXrefs := fr.GetChildren()
                children := make([]*IndividualRecord, 0, len(childXrefs))
                for _, childXref := range childXrefs </span><span class="cov0" title="0">{
                        childRecord := tree.GetIndividual(childXref)
                        if childIndi, ok := childRecord.(*IndividualRecord); ok </span><span class="cov0" title="0">{
                                children = append(children, childIndi)
                        }</span>
                }

                // Add to map (spouse may be nil for unknown spouse)
                <span class="cov0" title="0">if len(children) &gt; 0 </span><span class="cov0" title="0">{
                        spouseChildren[spouse] = children
                }</span>
        }

        // Also check for families with unknown spouse
        <span class="cov0" title="0">unknownSpouseFamily, err := ir.FamilyWithUnknownSpouse()
        if err == nil &amp;&amp; unknownSpouseFamily != nil </span><span class="cov0" title="0">{
                childXrefs := unknownSpouseFamily.GetChildren()
                children := make([]*IndividualRecord, 0, len(childXrefs))
                for _, childXref := range childXrefs </span><span class="cov0" title="0">{
                        childRecord := tree.GetIndividual(childXref)
                        if childIndi, ok := childRecord.(*IndividualRecord); ok </span><span class="cov0" title="0">{
                                children = append(children, childIndi)
                        }</span>
                }
                <span class="cov0" title="0">if len(children) &gt; 0 </span><span class="cov0" title="0">{
                        spouseChildren[nil] = children
                }</span>
        }

        <span class="cov0" title="0">return spouseChildren, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package types

import (
        "fmt"
        "sort"
        "strings"
)

// GedcomLine represents a single line in a GEDCOM file with hierarchical structure.
// Each line has a level (0, 1, 2, etc.), a tag (e.g., "NAME", "BIRT"), an optional
// value, and can have child lines that are subordinate to it.
//
// The hierarchical structure is maintained through:
//   - Parent pointer: Links to the parent line
//   - Children map: Groups child lines by tag for efficient access
//
// This structure allows representing the complete nested hierarchy of a GEDCOM file.
type GedcomLine struct {
        Level      int                    // 0, 1, 2, etc.
        Tag        string                 // TAG name (e.g., "NAME", "BIRT")
        Value      string                 // Value after tag
        XrefID     string                 // Cross-reference ID (e.g., "@I1@")
        LineNumber int                    // Original line number in file
        Parent     *GedcomLine            // Parent line (nil for level 0)
        Children   map[string][]*GedcomLine // Children grouped by tag
}

// NewGedcomLine creates a new GedcomLine with the specified fields.
func NewGedcomLine(level int, tag, value, xrefID string) *GedcomLine <span class="cov9" title="250">{
        return &amp;GedcomLine{
                Level:    level,
                Tag:      tag,
                Value:    value,
                XrefID:   xrefID,
                Children: make(map[string][]*GedcomLine),
        }
}</span>

// AddChild adds a child line to this line and sets the child's parent.
func (gl *GedcomLine) AddChild(child *GedcomLine) <span class="cov8" title="147">{
        if gl.Children == nil </span><span class="cov1" title="1">{
                gl.Children = make(map[string][]*GedcomLine)
        }</span>
        <span class="cov8" title="147">gl.Children[child.Tag] = append(gl.Children[child.Tag], child)
        child.Parent = gl</span>
}

// GetValue retrieves a value using dot notation selector (e.g., "BIRT.DATE").
// Returns empty string if not found.
func (gl *GedcomLine) GetValue(selector string) string <span class="cov7" title="88">{
        if selector == "" </span><span class="cov3" title="4">{
                return gl.Value
        }</span>

        <span class="cov7" title="84">parts := strings.Split(selector, ".")
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return gl.Value
        }</span>

        <span class="cov7" title="84">currentTag := parts[0]
        remaining := strings.Join(parts[1:], ".")

        if children, ok := gl.Children[currentTag]; ok </span><span class="cov7" title="79">{
                for _, child := range children </span><span class="cov7" title="79">{
                        if len(parts) == 1 </span><span class="cov6" title="53">{
                                return child.Value
                        }</span>
                        <span class="cov5" title="26">if result := child.GetValue(remaining); result != "" </span><span class="cov5" title="26">{
                                return result
                        }</span>
                }
        }

        <span class="cov3" title="5">return ""</span>
}

// GetLines retrieves all lines matching the selector using dot notation.
func (gl *GedcomLine) GetLines(selector string) []*GedcomLine <span class="cov10" title="421">{
        if selector == "" </span><span class="cov1" title="1">{
                return []*GedcomLine{gl}
        }</span>

        <span class="cov9" title="420">parts := strings.Split(selector, ".")
        currentTag := parts[0]
        remaining := strings.Join(parts[1:], ".")

        results := make([]*GedcomLine, 0)
        if children, ok := gl.Children[currentTag]; ok </span><span class="cov7" title="87">{
                for _, child := range children </span><span class="cov7" title="102">{
                        if len(parts) == 1 </span><span class="cov7" title="98">{
                                results = append(results, child)
                        }</span> else<span class="cov3" title="4"> {
                                results = append(results, child.GetLines(remaining)...)
                        }</span>
                }
        }

        <span class="cov9" title="420">return results</span>
}

// ToGED converts the line and all its children to GEDCOM format.
// Returns a slice of strings, one per line.
// Children are sorted by tag for consistent output.
func (gl *GedcomLine) ToGED() []string <span class="cov4" title="10">{
        lines := []string{gl.toGEDLine()}
        
        // Collect all tags and sort them for consistent output
        tags := make([]string, 0, len(gl.Children))
        for tag := range gl.Children </span><span class="cov3" title="5">{
                tags = append(tags, tag)
        }</span>
        <span class="cov4" title="10">sort.Strings(tags)
        
        // Process children in sorted tag order
        for _, tag := range tags </span><span class="cov3" title="5">{
                children := gl.Children[tag]
                for _, child := range children </span><span class="cov3" title="5">{
                        lines = append(lines, child.ToGED()...)
                }</span>
        }
        
        <span class="cov4" title="10">return lines</span>
}

// toGEDLine converts a single line to GEDCOM format string.
func (gl *GedcomLine) toGEDLine() string <span class="cov4" title="10">{
        var parts []string
        parts = append(parts, fmt.Sprintf("%d", gl.Level))
        
        if gl.XrefID != "" </span><span class="cov2" title="3">{
                parts = append(parts, gl.XrefID)
        }</span>
        
        <span class="cov4" title="10">parts = append(parts, gl.Tag)
        
        if gl.Value != "" </span><span class="cov3" title="6">{
                parts = append(parts, gl.Value)
        }</span>
        
        <span class="cov4" title="10">return strings.Join(parts, " ")</span>
}

// SetValue sets a value using dot notation selector (e.g., "GEDC.VERS").
// Creates the path if it doesn't exist.
func (gl *GedcomLine) SetValue(selector string, value string) <span class="cov3" title="5">{
        if selector == "" </span><span class="cov1" title="1">{
                gl.Value = value
                return
        }</span>

        <span class="cov3" title="4">parts := strings.Split(selector, ".")
        if len(parts) == 0 </span><span class="cov0" title="0">{
                gl.Value = value
                return
        }</span>

        <span class="cov3" title="4">current := gl
        // Navigate/create path for all parts except the last
        for i := 0; i &lt; len(parts)-1; i++ </span><span class="cov2" title="3">{
                tag := parts[i]
                if current.Children == nil </span><span class="cov0" title="0">{
                        current.Children = make(map[string][]*GedcomLine)
                }</span>
                
                <span class="cov2" title="3">children, exists := current.Children[tag]
                if !exists || len(children) == 0 </span><span class="cov2" title="2">{
                        // Create new child line
                        child := NewGedcomLine(current.Level+1, tag, "", "")
                        current.AddChild(child)
                        current = child
                }</span> else<span class="cov1" title="1"> {
                        // Use first existing child
                        current = children[0]
                }</span>
        }

        // Set value on the last part
        <span class="cov3" title="4">lastTag := parts[len(parts)-1]
        if current.Children == nil </span><span class="cov0" title="0">{
                current.Children = make(map[string][]*GedcomLine)
        }</span>
        
        <span class="cov3" title="4">children, exists := current.Children[lastTag]
        if !exists || len(children) == 0 </span><span class="cov2" title="3">{
                // Create new child line with value
                child := NewGedcomLine(current.Level+1, lastTag, value, "")
                current.AddChild(child)
        }</span> else<span class="cov1" title="1"> {
                // Update existing child's value
                children[0].Value = value
        }</span>
}

</pre>
		
		<pre class="file" id="file14" style="display: none">package types

// MultimediaRecord represents a Multimedia Object (OBJE) record.
type MultimediaRecord struct {
        *BaseRecord
}

// NewMultimediaRecord creates a new MultimediaRecord from a GedcomLine.
func NewMultimediaRecord(line *GedcomLine) *MultimediaRecord <span class="cov10" title="3">{
        return &amp;MultimediaRecord{
                BaseRecord: NewBaseRecord(line),
        }
}</span>

// GetFile returns the file reference (FILE).
func (mr *MultimediaRecord) GetFile() string <span class="cov1" title="1">{
        return mr.GetValue("FILE")
}</span>

// GetForm returns the media format (FORM).
func (mr *MultimediaRecord) GetForm() string <span class="cov1" title="1">{
        return mr.GetValue("FORM")
}</span>

// GetTitle returns the media title (TITL).
func (mr *MultimediaRecord) GetTitle() string <span class="cov1" title="1">{
        return mr.GetValue("TITL")
}</span>



</pre>
		
		<pre class="file" id="file15" style="display: none">package types

import (
        "fmt"
        "strings"
)

// NameType represents the type of a GEDCOM name.
type NameType string

const (
        NameTypeBirth     NameType = "birth"
        NameTypeMarried   NameType = "married"
        NameTypeAka       NameType = "aka"
        NameTypeReligious NameType = "religious"
        NameTypeOther     NameType = "other"
        NameTypeUnknown   NameType = "unknown"
)

// GedcomName represents a parsed GEDCOM name with structured components.
// Follows GEDCOM 5.5.1 specification for NAME records.
type GedcomName struct {
        Original string   // Original GEDCOM name string
        Type     NameType // birth, married, aka, religious, etc.

        // Name components (GEDCOM 5.5.1 sub-tags)
        Prefix        string // NPFX: Dr., Mr., Mrs., etc.
        Given         string // GIVN: First/middle names
        Nickname      string // NICK: Nickname
        SurnamePrefix string // SPFX: van, de, la, etc.
        Surname       string // SURN: Last name
        Suffix        string // NSFX: Jr., Sr., III, etc.

        // Parsed status
        IsParsed   bool
        ParseError error
}

// ParseName parses a GEDCOM NAME line and returns a GedcomName.
// Takes a GedcomLine (NAME record) as input to access sub-tags.
// Supports full GEDCOM 5.5.1 specification:
//   - Sub-tags: NPFX, GIVN, NICK, SPFX, SURN, NSFX, TYPE
//   - NAME value parsing when sub-tags are missing
//   - Multiple name formats: "Given /Surname/", "Given Surname", etc.
func ParseName(nameLine *GedcomLine) (*GedcomName, error) <span class="cov6" title="33">{
        if nameLine == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("name line is nil")
        }</span>

        <span class="cov6" title="32">if nameLine.Tag != "NAME" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("expected NAME tag, got %s", nameLine.Tag)
        }</span>

        <span class="cov6" title="31">name := &amp;GedcomName{
                Original:   strings.TrimSpace(nameLine.Value),
                Type:       NameTypeUnknown,
                IsParsed:   false,
                ParseError: nil,
        }

        // Extract sub-tags (GEDCOM 5.5.1 specification)
        if prefixLines := nameLine.GetLines("NPFX"); len(prefixLines) &gt; 0 </span><span class="cov2" title="2">{
                name.Prefix = strings.TrimSpace(prefixLines[0].Value)
        }</span>

        <span class="cov6" title="31">if givenLines := nameLine.GetLines("GIVN"); len(givenLines) &gt; 0 </span><span class="cov2" title="2">{
                name.Given = strings.TrimSpace(givenLines[0].Value)
        }</span>

        <span class="cov6" title="31">if nickLines := nameLine.GetLines("NICK"); len(nickLines) &gt; 0 </span><span class="cov2" title="2">{
                name.Nickname = strings.TrimSpace(nickLines[0].Value)
        }</span>

        <span class="cov6" title="31">if spfxLines := nameLine.GetLines("SPFX"); len(spfxLines) &gt; 0 </span><span class="cov2" title="2">{
                name.SurnamePrefix = strings.TrimSpace(spfxLines[0].Value)
        }</span>

        <span class="cov6" title="31">if surnLines := nameLine.GetLines("SURN"); len(surnLines) &gt; 0 </span><span class="cov2" title="3">{
                name.Surname = strings.TrimSpace(surnLines[0].Value)
        }</span>

        <span class="cov6" title="31">if suffixLines := nameLine.GetLines("NSFX"); len(suffixLines) &gt; 0 </span><span class="cov2" title="2">{
                name.Suffix = strings.TrimSpace(suffixLines[0].Value)
        }</span>

        // Extract name type
        <span class="cov6" title="31">if typeLines := nameLine.GetLines("TYPE"); len(typeLines) &gt; 0 </span><span class="cov5" title="16">{
                typeStr := strings.ToLower(strings.TrimSpace(typeLines[0].Value))
                switch typeStr </span>{
                case "birth":<span class="cov3" title="6">
                        name.Type = NameTypeBirth</span>
                case "married":<span class="cov3" title="6">
                        name.Type = NameTypeMarried</span>
                case "aka":<span class="cov1" title="1">
                        name.Type = NameTypeAka</span>
                case "religious":<span class="cov1" title="1">
                        name.Type = NameTypeReligious</span>
                case "unknown":<span class="cov1" title="1">
                        name.Type = NameTypeUnknown</span>
                case "":<span class="cov0" title="0"></span>
                        // Empty type, keep NameTypeUnknown (default)
                default:<span class="cov1" title="1">
                        // Unknown type value, treat as "other"
                        name.Type = NameTypeOther</span>
                }
        }

        // If sub-tags are missing, try to parse from NAME value
        <span class="cov6" title="31">if name.Given == "" &amp;&amp; name.Surname == "" &amp;&amp; name.Original != "" </span><span class="cov6" title="27">{
                parseNameValue(name, name.Original)
        }</span>

        // Validate
        <span class="cov6" title="31">if !name.IsValid() </span><span class="cov1" title="1">{
                name.ParseError = fmt.Errorf("name has no given name or surname")
                return name, name.ParseError
        }</span>

        <span class="cov6" title="30">name.IsParsed = true
        return name, nil</span>
}

// parseNameValue parses the NAME value string when sub-tags are missing.
// Handles formats like "Given /Surname/", "Dr. Given /Surname/ Jr.", etc.
func parseNameValue(name *GedcomName, nameStr string) <span class="cov6" title="27">{
        nameStr = strings.TrimSpace(nameStr)
        if nameStr == "" </span><span class="cov0" title="0">{
                return
        }</span>

        // Look for /Surname/ pattern (standard GEDCOM format)
        <span class="cov6" title="27">startIdx := -1
        endIdx := -1
        for i, r := range nameStr </span><span class="cov10" title="302">{
                if r == '/' </span><span class="cov7" title="50">{
                        if startIdx == -1 </span><span class="cov6" title="25">{
                                startIdx = i + 1
                        }</span> else<span class="cov6" title="25"> {
                                endIdx = i
                                break</span>
                        }
                }
        }

        <span class="cov6" title="27">if startIdx &gt; 0 &amp;&amp; endIdx &gt; startIdx </span><span class="cov6" title="25">{
                // Extract surname between slashes
                name.Surname = strings.TrimSpace(nameStr[startIdx:endIdx])

                // Extract given name (everything before the first slash)
                givenPart := strings.TrimSpace(nameStr[:startIdx-1])
                if givenPart != "" </span><span class="cov6" title="25">{
                        // Try to extract prefix and suffix from given part
                        parts := strings.Fields(givenPart)
                        if len(parts) &gt; 0 </span><span class="cov6" title="25">{
                        // Check if first part is a prefix (common prefixes)
                        firstPart := strings.ToUpper(parts[0])
                        commonPrefixes := []string{"DR", "DR.", "MR", "MR.", "MRS", "MRS.", "MS", "MS.", "PROF", "PROF.", "REV", "REV."}
                        for _, prefix := range commonPrefixes </span><span class="cov9" title="300">{
                                if firstPart == prefix || strings.HasPrefix(firstPart, prefix) </span><span class="cov0" title="0">{
                                        name.Prefix = parts[0]
                                        parts = parts[1:]
                                        break</span>
                                }
                        }

                        // Check if last part is a suffix (common suffixes)
                        <span class="cov6" title="25">if len(parts) &gt; 0 </span><span class="cov6" title="25">{
                                lastPart := strings.ToUpper(parts[len(parts)-1])
                                commonSuffixes := []string{"JR", "JR.", "SR", "SR.", "II", "III", "IV", "V"}
                                for _, suffix := range commonSuffixes </span><span class="cov9" title="200">{
                                        if lastPart == suffix </span><span class="cov0" title="0">{
                                                name.Suffix = parts[len(parts)-1]
                                                parts = parts[:len(parts)-1]
                                                break</span>
                                        }
                                }

                                        // Remaining parts are the given name
                                        <span class="cov6" title="25">if len(parts) &gt; 0 </span><span class="cov6" title="25">{
                                                name.Given = strings.Join(parts, " ")
                                        }</span>
                                }
                        }
                }
        } else<span class="cov2" title="2"> {
                // No slashes found, try to parse as unstructured name
                // Simple heuristic: split on spaces, assume last word is surname
                parts := strings.Fields(nameStr)
                if len(parts) &gt; 1 </span><span class="cov2" title="2">{
                        // Last part might be surname
                        name.Surname = parts[len(parts)-1]
                        // Everything else is given name
                        name.Given = strings.Join(parts[:len(parts)-1], " ")
                }</span> else<span class="cov0" title="0"> if len(parts) == 1 </span><span class="cov0" title="0">{
                        // Single word - assume it's given name
                        name.Given = parts[0]
                }</span>
        }
}

// reconstructFullName reconstructs the full name from components.
// Format: "Prefix Given SurnamePrefix Surname Suffix"
func (gn *GedcomName) reconstructFullName() string <span class="cov2" title="3">{
        parts := make([]string, 0, 6)

        if gn.Prefix != "" </span><span class="cov2" title="2">{
                parts = append(parts, gn.Prefix)
        }</span>

        <span class="cov2" title="3">if gn.Given != "" </span><span class="cov2" title="3">{
                parts = append(parts, gn.Given)
        }</span>

        <span class="cov2" title="3">if gn.SurnamePrefix != "" </span><span class="cov1" title="1">{
                parts = append(parts, gn.SurnamePrefix)
        }</span>

        <span class="cov2" title="3">if gn.Surname != "" </span><span class="cov2" title="3">{
                parts = append(parts, gn.Surname)
        }</span>

        <span class="cov2" title="3">if gn.Suffix != "" </span><span class="cov2" title="2">{
                parts = append(parts, gn.Suffix)
        }</span>

        <span class="cov2" title="3">if len(parts) == 0 </span><span class="cov0" title="0">{
                // Fallback to original if no components
                return gn.Original
        }</span>

        <span class="cov2" title="3">return strings.Join(parts, " ")</span>
}

// FullName returns the reconstructed full name.
// If reconstruction failed, returns the original name string.
func (gn *GedcomName) FullName() string <span class="cov2" title="3">{
        fullName := gn.reconstructFullName()
        if fullName != "" </span><span class="cov2" title="3">{
                return fullName
        }</span>
        <span class="cov0" title="0">return gn.Original</span>
}

// IsValid returns true if the name has at least a given name or surname.
func (gn *GedcomName) IsValid() bool <span class="cov6" title="36">{
        return (gn.Given != "" || gn.Surname != "") &amp;&amp; gn.ParseError == nil
}</span>

// String returns a string representation of the name.
func (gn *GedcomName) String() string <span class="cov0" title="0">{
        return gn.FullName()
}</span>

// GetGivenName returns the given name (first/middle names).
func (gn *GedcomName) GetGivenName() string <span class="cov0" title="0">{
        return gn.Given
}</span>

// GetSurname returns the surname (last name).
func (gn *GedcomName) GetSurname() string <span class="cov0" title="0">{
        return gn.Surname
}</span>

// GetFullSurname returns the full surname including prefix (e.g., "van der Berg").
func (gn *GedcomName) GetFullSurname() string <span class="cov3" title="5">{
        if gn.SurnamePrefix != "" &amp;&amp; gn.Surname != "" </span><span class="cov2" title="2">{
                return gn.SurnamePrefix + " " + gn.Surname
        }</span>
        <span class="cov2" title="3">if gn.SurnamePrefix != "" </span><span class="cov1" title="1">{
                return gn.SurnamePrefix
        }</span>
        <span class="cov2" title="2">return gn.Surname</span>
}

// HasPrefix returns true if the name has a prefix (NPFX).
func (gn *GedcomName) HasPrefix() bool <span class="cov2" title="2">{
        return gn.Prefix != ""
}</span>

// HasSuffix returns true if the name has a suffix (NSFX).
func (gn *GedcomName) HasSuffix() bool <span class="cov2" title="2">{
        return gn.Suffix != ""
}</span>

// HasNickname returns true if the name has a nickname (NICK).
func (gn *GedcomName) HasNickname() bool <span class="cov1" title="1">{
        return gn.Nickname != ""
}</span>

// HasSurnamePrefix returns true if the name has a surname prefix (SPFX).
func (gn *GedcomName) HasSurnamePrefix() bool <span class="cov0" title="0">{
        return gn.SurnamePrefix != ""
}</span>

</pre>
		
		<pre class="file" id="file16" style="display: none">package types

// NameNode represents a structured name node.
// Wraps GedcomName to provide a node-like interface similar to elliotchance.
type NameNode struct {
        // Name is the parsed GedcomName
        Name *GedcomName

        // OriginalLine is the original GedcomLine for accessing sub-tags
        OriginalLine *GedcomLine
}

// NewNameNode creates a new NameNode from a GedcomName.
func NewNameNode(name *GedcomName) *NameNode <span class="cov1" title="1">{
        if name == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">return &amp;NameNode{Name: name}</span>
}

// NewNameNodeFromLine creates a NameNode from a GedcomLine (NAME tag).
func NewNameNodeFromLine(line *GedcomLine) *NameNode <span class="cov1" title="1">{
        if line == nil || line.Tag != "NAME" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">name, err := ParseName(line)
        if err != nil || name == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">return &amp;NameNode{
                Name:         name,
                OriginalLine: line,
        }</span>
}

// GivenName returns the given name (first name).
func (nn *NameNode) GivenName() string <span class="cov10" title="2">{
        if nn == nil || nn.Name == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov10" title="2">return nn.Name.Given</span>
}

// Surname returns the surname (last name).
func (nn *NameNode) Surname() string <span class="cov1" title="1">{
        if nn == nil || nn.Name == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">return nn.Name.Surname</span>
}

// Prefix returns the name prefix (Dr., Mr., Mrs., etc.).
func (nn *NameNode) Prefix() string <span class="cov1" title="1">{
        if nn == nil || nn.Name == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">return nn.Name.Prefix</span>
}

// Suffix returns the name suffix (Jr., Sr., III, etc.).
func (nn *NameNode) Suffix() string <span class="cov1" title="1">{
        if nn == nil || nn.Name == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">return nn.Name.Suffix</span>
}

// Nickname returns the nickname.
func (nn *NameNode) Nickname() string <span class="cov0" title="0">{
        if nn == nil || nn.Name == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return nn.Name.Nickname</span>
}

// SurnamePrefix returns the surname prefix (van, de, la, etc.).
func (nn *NameNode) SurnamePrefix() string <span class="cov0" title="0">{
        if nn == nil || nn.Name == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return nn.Name.SurnamePrefix</span>
}

// Type returns the name type (birth, married, aka, etc.).
func (nn *NameNode) Type() NameType <span class="cov1" title="1">{
        if nn == nil || nn.Name == nil </span><span class="cov0" title="0">{
                return NameTypeUnknown
        }</span>
        <span class="cov1" title="1">return nn.Name.Type</span>
}

// String returns the formatted name string.
func (nn *NameNode) String() string <span class="cov0" title="0">{
        if nn == nil || nn.Name == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return nn.Name.Original</span>
}

// IsValid returns true if the name is valid.
func (nn *NameNode) IsValid() bool <span class="cov0" title="0">{
        return nn != nil &amp;&amp; nn.Name != nil &amp;&amp; nn.Name.IsParsed
}</span>

</pre>
		
		<pre class="file" id="file17" style="display: none">package types

// NoteRecord represents a Note (NOTE) record.
type NoteRecord struct {
        *BaseRecord
}

// NewNoteRecord creates a new NoteRecord from a GedcomLine.
func NewNoteRecord(line *GedcomLine) *NoteRecord <span class="cov10" title="4">{
        return &amp;NoteRecord{
                BaseRecord: NewBaseRecord(line),
        }
}</span>

// GetText returns the note text (value of the NOTE line or CONT/CONC lines).
func (nr *NoteRecord) GetText() string <span class="cov5" title="2">{
        return nr.GetValue("")
}</span>



</pre>
		
		<pre class="file" id="file18" style="display: none">package types

import (
        "fmt"
        "strings"
)

// GedcomPlace represents a parsed GEDCOM place with hierarchical components.
type GedcomPlace struct {
        Original   string   // Original GEDCOM place string
        Components []string // Parsed components (from most specific to least specific)

        // Hierarchical components (extracted from Components)
        City       string
        County     string
        State      string
        Country    string
        PostalCode string

        // Geographic data (optional, for future geocoding support)
        Latitude  float64
        Longitude float64

        // Parsed status
        IsParsed   bool
        ParseError error
}

// ParsePlace parses a GEDCOM place string and extracts hierarchical components.
// Supports various place formats:
//   - "Rapid City" (simple)
//   - "Rapid City, South Dakota" (city, state)
//   - "Rapid City, Pennington, South Dakota, USA" (full hierarchy)
//   - "New York, NY, USA" (with abbreviations)
//
// GEDCOM places are typically comma-separated, with the most specific
// location first, followed by progressively broader locations.
func ParsePlace(placeStr string) (*GedcomPlace, error) <span class="cov6" title="11">{
        if placeStr == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("empty place string")
        }</span>

        <span class="cov6" title="10">place := &amp;GedcomPlace{
                Original:   strings.TrimSpace(placeStr),
                IsParsed:   false,
                ParseError: nil,
        }

        // Split by comma and trim whitespace
        parts := strings.Split(placeStr, ",")
        components := make([]string, 0, len(parts))
        for _, part := range parts </span><span class="cov8" title="25">{
                trimmed := strings.TrimSpace(part)
                if trimmed != "" </span><span class="cov8" title="25">{
                        components = append(components, trimmed)
                }</span>
        }

        <span class="cov6" title="10">if len(components) == 0 </span><span class="cov0" title="0">{
                place.ParseError = fmt.Errorf("no components found in place string")
                return place, place.ParseError
        }</span>

        <span class="cov6" title="10">place.Components = components

        // Extract hierarchical components
        // GEDCOM format: most specific to least specific (e.g., City, County, State, Country)
        switch len(components) </span>{
        case 1:<span class="cov1" title="1">
                // Single component - assume it's a city
                place.City = components[0]</span>
        case 2:<span class="cov4" title="5">
                // Two components - typically City, State or City, Country
                place.City = components[0]
                // Try to determine if second is state or country
                if isLikelyCountry(components[1]) </span><span class="cov0" title="0">{
                        place.Country = components[1]
                }</span> else<span class="cov4" title="5"> {
                        place.State = components[1]
                }</span>
        case 3:<span class="cov2" title="2">
                // Three components - typically City, State, Country
                place.City = components[0]
                place.State = components[1]
                place.Country = components[2]</span>
        case 4:<span class="cov2" title="2">
                // Four components - typically City, County, State, Country
                place.City = components[0]
                place.County = components[1]
                place.State = components[2]
                place.Country = components[3]</span>
        default:<span class="cov0" title="0">
                // Five or more components
                place.City = components[0]
                if len(components) &gt;= 2 </span><span class="cov0" title="0">{
                        place.County = components[1]
                }</span>
                <span class="cov0" title="0">if len(components) &gt;= 3 </span><span class="cov0" title="0">{
                        place.State = components[2]
                }</span>
                <span class="cov0" title="0">if len(components) &gt;= 4 </span><span class="cov0" title="0">{
                        place.Country = components[3]
                }</span>
                // Additional components beyond 4 are stored in Components but not mapped
        }

        <span class="cov6" title="10">place.IsParsed = true
        return place, nil</span>
}

// isLikelyCountry attempts to determine if a component is likely a country.
// This is a simple heuristic - could be enhanced with a country list.
func isLikelyCountry(component string) bool <span class="cov4" title="5">{
        upper := strings.ToUpper(component)
        // Common country indicators
        countryIndicators := []string{"USA", "US", "UNITED STATES", "UK", "UNITED KINGDOM", "CANADA", "AUSTRALIA", "FRANCE", "GERMANY", "ITALY", "SPAIN"}
        for _, indicator := range countryIndicators </span><span class="cov10" title="55">{
                if upper == indicator || strings.Contains(upper, indicator) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov4" title="5">return false</span>
}

// ToFormatted formats the place with the given separator.
// Returns the original string if parsing failed.
func (gp *GedcomPlace) ToFormatted(separator string) string <span class="cov3" title="3">{
        if !gp.IsParsed || len(gp.Components) == 0 </span><span class="cov0" title="0">{
                return gp.Original
        }</span>
        <span class="cov3" title="3">return strings.Join(gp.Components, separator)</span>
}

// GetComponent returns the component at the specified level.
// Level 0 is the most specific (city), higher levels are broader.
// Returns empty string if level is out of range.
func (gp *GedcomPlace) GetComponent(level int) string <span class="cov4" title="5">{
        if !gp.IsParsed || level &lt; 0 || level &gt;= len(gp.Components) </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov4" title="4">return gp.Components[level]</span>
}

// IsValid returns true if the place was successfully parsed.
func (gp *GedcomPlace) IsValid() bool <span class="cov5" title="8">{
        return gp.IsParsed &amp;&amp; gp.ParseError == nil
}</span>

// Normalize returns a normalized version of the place.
// Currently just trims and standardizes capitalization.
// Could be enhanced with place name standardization.
func (gp *GedcomPlace) Normalize() *GedcomPlace <span class="cov1" title="1">{
        if !gp.IsValid() </span><span class="cov0" title="0">{
                return gp
        }</span>

        <span class="cov1" title="1">normalized := &amp;GedcomPlace{
                Original:   gp.Original,
                Components: make([]string, len(gp.Components)),
                City:       strings.TrimSpace(gp.City),
                County:     strings.TrimSpace(gp.County),
                State:      strings.TrimSpace(gp.State),
                Country:    strings.TrimSpace(gp.Country),
                PostalCode: strings.TrimSpace(gp.PostalCode),
                IsParsed:   true,
        }

        // Normalize components
        for i, comp := range gp.Components </span><span class="cov2" title="2">{
                normalized.Components[i] = strings.TrimSpace(comp)
        }</span>

        <span class="cov1" title="1">return normalized</span>
}

// String returns a string representation of the place.
func (gp *GedcomPlace) String() string <span class="cov1" title="1">{
        if !gp.IsValid() </span><span class="cov0" title="0">{
                return gp.Original
        }</span>
        <span class="cov1" title="1">return gp.ToFormatted(", ")</span>
}

// Geocode is a placeholder for future geocoding functionality.
// Would look up latitude/longitude for the place.
func (gp *GedcomPlace) Geocode() error <span class="cov0" title="0">{
        // TODO: Implement geocoding using a geocoding service
        // For now, just return nil (no-op)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package types

import "strings"

// PlaceNode represents a structured place with jurisdictional components.
// Similar to elliotchance's PlaceNode but adapted for gedcom-go's structure.
type PlaceNode struct {
        // Original is the original place string from GEDCOM
        Original string

        // Components are the parsed jurisdictional components
        // Format: Name, County, State, Country
        Components []string

        // Name is the first component (city/town name)
        Name string

        // County is the second component
        County string

        // State is the third component (state/province)
        State string

        // Country is the fourth component
        Country string

        // Latitude and Longitude if available
        Latitude  string
        Longitude string

        // OriginalLine is the original GedcomLine for accessing sub-tags
        OriginalLine *GedcomLine
}

// NewPlaceNode creates a new PlaceNode from a place string.
func NewPlaceNode(placeStr string) *PlaceNode <span class="cov7" title="8">{
        if placeStr == "" </span><span class="cov0" title="0">{
                return &amp;PlaceNode{}
        }</span>

        <span class="cov7" title="8">pn := &amp;PlaceNode{
                Original: strings.TrimSpace(placeStr),
        }

        // Parse jurisdictional components (comma-separated)
        components := strings.Split(placeStr, ",")
        for i, comp := range components </span><span class="cov10" title="22">{
                components[i] = strings.TrimSpace(comp)
        }</span>
        <span class="cov7" title="8">pn.Components = components

        // Extract components
        if len(components) &gt; 0 </span><span class="cov7" title="8">{
                pn.Name = components[0]
        }</span>
        <span class="cov7" title="8">if len(components) &gt; 1 </span><span class="cov6" title="7">{
                pn.County = components[1]
        }</span>
        <span class="cov7" title="8">if len(components) &gt; 2 </span><span class="cov6" title="6">{
                pn.State = components[2]
        }</span>
        <span class="cov7" title="8">if len(components) &gt; 3 </span><span class="cov1" title="1">{
                pn.Country = components[3]
        }</span>

        <span class="cov7" title="8">return pn</span>
}

// NewPlaceNodeFromLine creates a PlaceNode from a GedcomLine (PLAC tag).
func NewPlaceNodeFromLine(line *GedcomLine) *PlaceNode <span class="cov5" title="5">{
        if line == nil || line.Tag != "PLAC" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov5" title="5">pn := NewPlaceNode(line.Value)

        // Extract latitude/longitude if present
        if latLines := line.GetLines("LATI"); len(latLines) &gt; 0 </span><span class="cov0" title="0">{
                pn.Latitude = latLines[0].Value
        }</span>
        <span class="cov5" title="5">if lonLines := line.GetLines("LONG"); len(lonLines) &gt; 0 </span><span class="cov0" title="0">{
                pn.Longitude = lonLines[0].Value
        }</span>

        // Extract FORM sub-tag if present (format specification)
        // Store original line for additional sub-tags
        <span class="cov5" title="5">pn.OriginalLine = line

        return pn</span>
}

// IsValid returns true if the place has at least a name.
func (pn *PlaceNode) IsValid() bool <span class="cov3" title="2">{
        return pn != nil &amp;&amp; pn.Name != ""
}</span>

// JurisdictionalName returns the full jurisdictional name.
// Returns the original string if components aren't properly formatted.
func (pn *PlaceNode) JurisdictionalName() string <span class="cov0" title="0">{
        if pn == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if len(pn.Components) &gt;= 4 </span><span class="cov0" title="0">{
                // Properly formatted: Name,County,State,Country
                return strings.Join(pn.Components, ",")
        }</span>

        // Return original if not in standard format
        <span class="cov0" title="0">return pn.Original</span>
}

// String returns the place as a string.
func (pn *PlaceNode) String() string <span class="cov0" title="0">{
        if pn == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return pn.Original</span>
}

// Format returns the place formatted with the specified separator.
func (pn *PlaceNode) Format(separator string) string <span class="cov0" title="0">{
        if pn == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return strings.Join(pn.Components, separator)</span>
}

</pre>
		
		<pre class="file" id="file20" style="display: none">package types

import (
        "crypto/rand"
        "fmt"
)

// RecordType represents the type of a GEDCOM record.
// Valid types are defined as constants below.
type RecordType string

const (
        RecordTypeHEAD RecordType = "HEAD"
        RecordTypeINDI RecordType = "INDI"
        RecordTypeFAM  RecordType = "FAM"
        RecordTypeNOTE RecordType = "NOTE"
        RecordTypeSOUR RecordType = "SOUR"
        RecordTypeREPO RecordType = "REPO"
        RecordTypeSUBM RecordType = "SUBM"
        RecordTypeOBJE RecordType = "OBJE"
        RecordTypeTRLR RecordType = "TRLR"
)

// Record represents a GEDCOM record (INDI, FAM, NOTE, etc.).
type Record interface {
        Type() RecordType
        XrefID() string
        UUID() string
        FirstLine() *GedcomLine
        GetValue(selector string) string
        GetValues(selector string) []string
        GetLines(selector string) []*GedcomLine
}

// BaseRecord provides a basic implementation of the Record interface.
type BaseRecord struct {
        firstLine  *GedcomLine
        recordType RecordType
        tree       *GedcomTree // Reference to the tree this record belongs to (set when added to tree)
        uuid       string      // System-generated UUID (v4 format)
}

// NewBaseRecord creates a new BaseRecord from a GedcomLine.
// A system-generated UUID is automatically assigned to the record.
func NewBaseRecord(line *GedcomLine) *BaseRecord <span class="cov8" title="76">{
        return &amp;BaseRecord{
                firstLine:  line,
                recordType: RecordType(line.Tag),
                uuid:       generateUUID(),
        }
}</span>

// generateUUID generates a UUID v4 (random UUID).
// Uses crypto/rand for cryptographically secure random number generation.
func generateUUID() string <span class="cov8" title="76">{
        b := make([]byte, 16)
        rand.Read(b)
        
        // Set version (4) and variant bits according to RFC 4122
        b[6] = (b[6] &amp; 0x0f) | 0x40 // Version 4
        b[8] = (b[8] &amp; 0x3f) | 0x80 // Variant 10
        
        return fmt.Sprintf("%08x-%04x-%04x-%04x-%12x",
                b[0:4], b[4:6], b[6:8], b[8:10], b[10:16])
}</span>

// Type returns the record type.
func (br *BaseRecord) Type() RecordType <span class="cov7" title="28">{
        return br.recordType
}</span>

// XrefID returns the cross-reference ID of the record.
func (br *BaseRecord) XrefID() string <span class="cov7" title="28">{
        return br.firstLine.XrefID
}</span>

// UUID returns the system-generated UUID of the record.
func (br *BaseRecord) UUID() string <span class="cov7" title="28">{
        return br.uuid
}</span>

// FirstLine returns the first line (level 0) of the record.
func (br *BaseRecord) FirstLine() *GedcomLine <span class="cov1" title="1">{
        return br.firstLine
}</span>

// GetValue retrieves a value using dot notation selector.
func (br *BaseRecord) GetValue(selector string) string <span class="cov7" title="46">{
        return br.firstLine.GetValue(selector)
}</span>

// GetValues retrieves all values matching the selector.
func (br *BaseRecord) GetValues(selector string) []string <span class="cov5" title="15">{
        lines := br.firstLine.GetLines(selector)
        values := make([]string, 0, len(lines))
        for _, line := range lines </span><span class="cov6" title="24">{
                if line.Value != "" </span><span class="cov6" title="24">{
                        values = append(values, line.Value)
                }</span>
        }
        <span class="cov5" title="15">return values</span>
}

// GetLines retrieves all lines matching the selector.
func (br *BaseRecord) GetLines(selector string) []*GedcomLine <span class="cov10" title="140">{
        return br.firstLine.GetLines(selector)
}</span>

// GetNotes returns all note xrefs.
// This method is shared by IndividualRecord and FamilyRecord.
func (br *BaseRecord) GetNotes() []string <span class="cov2" title="2">{
        return br.GetValues("NOTE")
}</span>

// GetSources returns all source xrefs.
// This method is shared by IndividualRecord and FamilyRecord.
func (br *BaseRecord) GetSources() []string <span class="cov2" title="2">{
        return br.GetValues("SOUR")
}</span>

// getTree returns the tree this record belongs to.
// Returns nil if the record hasn't been added to a tree yet.
func (br *BaseRecord) getTree() *GedcomTree <span class="cov0" title="0">{
        return br.tree
}</span>

// setTree sets the tree reference for this record.
// This is called automatically when a record is added to a tree.
func (br *BaseRecord) setTree(tree *GedcomTree) <span class="cov6" title="18">{
        br.tree = tree
}</span>

</pre>
		
		<pre class="file" id="file21" style="display: none">package types

// RecordFactory creates specialized Record instances based on the record type.
type RecordFactory struct{}

// NewRecordFactory creates a new RecordFactory.
func NewRecordFactory() *RecordFactory <span class="cov3" title="2">{
        return &amp;RecordFactory{}
}</span>

// CreateRecord creates a specialized Record from a GedcomLine.
// Returns the appropriate record type based on the line's tag.
func (rf *RecordFactory) CreateRecord(line *GedcomLine) Record <span class="cov10" title="11">{
        if line == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov9" title="10">switch RecordType(line.Tag) </span>{
        case RecordTypeINDI:<span class="cov1" title="1">
                return NewIndividualRecord(line)</span>
        case RecordTypeFAM:<span class="cov1" title="1">
                return NewFamilyRecord(line)</span>
        case RecordTypeHEAD:<span class="cov1" title="1">
                return NewHeaderRecord(line)</span>
        case RecordTypeNOTE:<span class="cov1" title="1">
                return NewNoteRecord(line)</span>
        case RecordTypeSOUR:<span class="cov1" title="1">
                return NewSourceRecord(line)</span>
        case RecordTypeREPO:<span class="cov1" title="1">
                return NewRepositoryRecord(line)</span>
        case RecordTypeSUBM:<span class="cov1" title="1">
                return NewSubmitterRecord(line)</span>
        case RecordTypeOBJE:<span class="cov1" title="1">
                return NewMultimediaRecord(line)</span>
        case RecordTypeTRLR:<span class="cov1" title="1">
                // TRLR doesn't need special handling, use BaseRecord
                return NewBaseRecord(line)</span>
        default:<span class="cov1" title="1">
                // Unknown record type, use BaseRecord
                return NewBaseRecord(line)</span>
        }
}



</pre>
		
		<pre class="file" id="file22" style="display: none">package types

// extractEvents extracts events from a record using the provided event tags.
// This is a shared helper for IndividualRecord.GetEvents() and FamilyRecord.GetEvents().
func extractEvents(record Record, eventTags []string) []map[string]interface{} <span class="cov2" title="2">{
        events := make([]map[string]interface{}, 0)
        for _, tag := range eventTags </span><span class="cov10" title="37">{
                eventLines := record.GetLines(tag)
                for _, line := range eventLines </span><span class="cov4" title="4">{
                        event := map[string]interface{}{
                                "type":        tag,
                                "date":        line.GetValue("DATE"),
                                "place":       line.GetValue("PLAC"),
                                "description": line.Value,
                        }
                        events = append(events, event)
                }</span>
        }
        <span class="cov2" title="2">return events</span>
}

</pre>
		
		<pre class="file" id="file23" style="display: none">package types

// RepositoryRecord represents a Repository (REPO) record.
type RepositoryRecord struct {
        *BaseRecord
}

// NewRepositoryRecord creates a new RepositoryRecord from a GedcomLine.
func NewRepositoryRecord(line *GedcomLine) *RepositoryRecord <span class="cov10" title="3">{
        return &amp;RepositoryRecord{
                BaseRecord: NewBaseRecord(line),
        }
}</span>

// GetName returns the repository name (NAME).
func (rr *RepositoryRecord) GetName() string <span class="cov1" title="1">{
        return rr.GetValue("NAME")
}</span>

// GetAddress returns the address lines (ADDR).
func (rr *RepositoryRecord) GetAddress() []string <span class="cov1" title="1">{
        return rr.GetValues("ADDR")
}</span>



</pre>
		
		<pre class="file" id="file24" style="display: none">package types

// SourceRecord represents a Source (SOUR) record.
type SourceRecord struct {
        *BaseRecord
}

// NewSourceRecord creates a new SourceRecord from a GedcomLine.
func NewSourceRecord(line *GedcomLine) *SourceRecord <span class="cov10" title="3">{
        return &amp;SourceRecord{
                BaseRecord: NewBaseRecord(line),
        }
}</span>

// GetTitle returns the source title (TITL).
func (sr *SourceRecord) GetTitle() string <span class="cov1" title="1">{
        return sr.GetValue("TITL")
}</span>

// GetAbbreviation returns the source abbreviation (ABBR).
func (sr *SourceRecord) GetAbbreviation() string <span class="cov1" title="1">{
        return sr.GetValue("ABBR")
}</span>

// GetRepository returns the repository xref (REPO).
func (sr *SourceRecord) GetRepository() string <span class="cov1" title="1">{
        return sr.GetValue("REPO")
}</span>



</pre>
		
		<pre class="file" id="file25" style="display: none">package types

// SubmitterRecord represents a Submitter (SUBM) record.
type SubmitterRecord struct {
        *BaseRecord
}

// NewSubmitterRecord creates a new SubmitterRecord from a GedcomLine.
func NewSubmitterRecord(line *GedcomLine) *SubmitterRecord <span class="cov10" title="3">{
        return &amp;SubmitterRecord{
                BaseRecord: NewBaseRecord(line),
        }
}</span>

// GetName returns the submitter name (NAME).
func (sr *SubmitterRecord) GetName() string <span class="cov1" title="1">{
        return sr.GetValue("NAME")
}</span>

// GetAddress returns the address lines (ADDR).
func (sr *SubmitterRecord) GetAddress() []string <span class="cov1" title="1">{
        return sr.GetValues("ADDR")
}</span>

// GetPhone returns the phone number (PHON).
func (sr *SubmitterRecord) GetPhone() string <span class="cov1" title="1">{
        return sr.GetValue("PHON")
}</span>



</pre>
		
		<pre class="file" id="file26" style="display: none">package types

// CreateTestIndividual is a convenience function for creating test individuals.
// This is a simple wrapper that can be extended with more options if needed.
func CreateTestIndividual(xref, name string) *IndividualRecord <span class="cov0" title="0">{
        indiLine := NewGedcomLine(0, "INDI", "", xref)
        if name != "" </span><span class="cov0" title="0">{
                indiLine.AddChild(NewGedcomLine(1, "NAME", name, ""))
        }</span>
        <span class="cov0" title="0">return NewIndividualRecord(indiLine)</span>
}

// CreateTestFamily is a convenience function for creating test families.
func CreateTestFamily(xref string, husband, wife string, children []string) *FamilyRecord <span class="cov0" title="0">{
        famLine := NewGedcomLine(0, "FAM", "", xref)
        if husband != "" </span><span class="cov0" title="0">{
                famLine.AddChild(NewGedcomLine(1, "HUSB", husband, ""))
        }</span>
        <span class="cov0" title="0">if wife != "" </span><span class="cov0" title="0">{
                famLine.AddChild(NewGedcomLine(1, "WIFE", wife, ""))
        }</span>
        <span class="cov0" title="0">for _, child := range children </span><span class="cov0" title="0">{
                famLine.AddChild(NewGedcomLine(1, "CHIL", child, ""))
        }</span>
        <span class="cov0" title="0">return NewFamilyRecord(famLine)</span>
}

// CreateTestTree creates a new empty GEDCOM tree for testing.
func CreateTestTree() *GedcomTree <span class="cov0" title="0">{
        return NewGedcomTree()
}</span>

</pre>
		
		<pre class="file" id="file27" style="display: none">// Package gedcom provides core data structures for GEDCOM files.
package types

import (
        "sync"
)

// GedcomTree represents the entire GEDCOM file structure.
// It serves as the root container for all parsed records and provides
// thread-safe access to individuals, families, notes, sources, and other
// record types.
//
// The tree maintains:
//   - Separate maps for each record type (individuals, families, etc.)
//   - A cross-reference index for fast lookups by xref ID
//   - Metadata such as encoding and version
//
// All methods are thread-safe and can be called concurrently.
type GedcomTree struct {
        mu sync.RWMutex

        // Records organized by type
        header       Record
        individuals  map[string]Record // key: xref_id
        families     map[string]Record
        notes        map[string]Record
        sources      map[string]Record
        repositories map[string]Record
        submitters   map[string]Record
        multimedia   map[string]Record

        // Cross-reference index (all records by xref_id)
        xrefIndex map[string]Record

        // UUID index (all records by UUID for fast lookup)
        uuidIndex map[string]Record

        // Metadata
        encoding string
        version  string

        // Graph for relationship traversal (lazy initialization)
        // Using interface{} to avoid import cycle with query package
        queryGraph interface{} // *query.Graph
        graphMu    sync.RWMutex
}

// NewGedcomTree creates a new empty GedcomTree.
func NewGedcomTree() *GedcomTree <span class="cov7" title="7">{
        return &amp;GedcomTree{
                individuals:  make(map[string]Record),
                families:     make(map[string]Record),
                notes:        make(map[string]Record),
                sources:      make(map[string]Record),
                repositories: make(map[string]Record),
                submitters:   make(map[string]Record),
                multimedia:   make(map[string]Record),
                xrefIndex:    make(map[string]Record),
                uuidIndex:    make(map[string]Record),
        }
}</span>

// AddRecord adds a record to the tree.
// For Step 1.5, we only handle level 0 records.
func (gt *GedcomTree) AddRecord(record Record) <span class="cov10" title="18">{
        gt.mu.Lock()
        defer gt.mu.Unlock()

        recordType := record.Type()
        xrefID := record.XrefID()

        // Set tree reference on the record (if it's a BaseRecord)
        if br, ok := record.(interface{ setTree(*GedcomTree) }); ok </span><span class="cov10" title="18">{
                br.setTree(gt)
        }</span>

        // Add to xref index if it has an xref
        <span class="cov10" title="18">if xrefID != "" </span><span class="cov9" title="16">{
                gt.xrefIndex[xrefID] = record
        }</span>

        // Add to UUID index (all records have UUIDs)
        <span class="cov10" title="18">gt.uuidIndex[record.UUID()] = record

        // Add to appropriate map based on type
        // Use a helper to reduce code duplication
        gt.addToTypeMap(recordType, xrefID, record)</span>
}

// addToTypeMap adds a record to the appropriate type-specific map.
// This helper reduces code duplication in AddRecord.
func (gt *GedcomTree) addToTypeMap(recordType RecordType, xrefID string, record Record) <span class="cov10" title="18">{
        switch recordType </span>{
        case RecordTypeHEAD:<span class="cov1" title="1">
                gt.header = record</span>
        case RecordTypeTRLR:<span class="cov1" title="1">
                // TRLR doesn't need to be stored separately
                return</span>
        case RecordTypeINDI:<span class="cov7" title="8">
                if xrefID != "" </span><span class="cov7" title="8">{
                        gt.individuals[xrefID] = record
                }</span>
        case RecordTypeFAM:<span class="cov4" title="3">
                if xrefID != "" </span><span class="cov4" title="3">{
                        gt.families[xrefID] = record
                }</span>
        case RecordTypeNOTE:<span class="cov1" title="1">
                if xrefID != "" </span><span class="cov1" title="1">{
                        gt.notes[xrefID] = record
                }</span>
        case RecordTypeSOUR:<span class="cov1" title="1">
                if xrefID != "" </span><span class="cov1" title="1">{
                        gt.sources[xrefID] = record
                }</span>
        case RecordTypeREPO:<span class="cov1" title="1">
                if xrefID != "" </span><span class="cov1" title="1">{
                        gt.repositories[xrefID] = record
                }</span>
        case RecordTypeSUBM:<span class="cov1" title="1">
                if xrefID != "" </span><span class="cov1" title="1">{
                        gt.submitters[xrefID] = record
                }</span>
        case RecordTypeOBJE:<span class="cov1" title="1">
                if xrefID != "" </span><span class="cov1" title="1">{
                        gt.multimedia[xrefID] = record
                }</span>
        }
}

// GetHeader returns the header record.
func (gt *GedcomTree) GetHeader() Record <span class="cov3" title="2">{
        gt.mu.RLock()
        defer gt.mu.RUnlock()
        return gt.header
}</span>

// GetIndividual returns an individual record by xref ID.
func (gt *GedcomTree) GetIndividual(xrefID string) Record <span class="cov3" title="2">{
        gt.mu.RLock()
        defer gt.mu.RUnlock()
        return gt.individuals[xrefID]
}</span>

// GetFamily returns a family record by xref ID.
func (gt *GedcomTree) GetFamily(xrefID string) Record <span class="cov1" title="1">{
        gt.mu.RLock()
        defer gt.mu.RUnlock()
        return gt.families[xrefID]
}</span>

// getAllRecords is a helper that safely copies a record map.
// Used by all GetAll* methods to reduce code duplication.
func (gt *GedcomTree) getAllRecords(source map[string]Record) map[string]Record <span class="cov7" title="8">{
        gt.mu.RLock()
        defer gt.mu.RUnlock()
        result := make(map[string]Record, len(source))
        for k, v := range source </span><span class="cov8" title="11">{
                result[k] = v
        }</span>
        <span class="cov7" title="8">return result</span>
}

// GetAllIndividuals returns all individual records.
func (gt *GedcomTree) GetAllIndividuals() map[string]Record <span class="cov3" title="2">{
        return gt.getAllRecords(gt.individuals)
}</span>

// GetAllFamilies returns all family records.
func (gt *GedcomTree) GetAllFamilies() map[string]Record <span class="cov1" title="1">{
        return gt.getAllRecords(gt.families)
}</span>

// GetAllNotes returns all note records.
func (gt *GedcomTree) GetAllNotes() map[string]Record <span class="cov1" title="1">{
        return gt.getAllRecords(gt.notes)
}</span>

// GetAllSources returns all source records.
func (gt *GedcomTree) GetAllSources() map[string]Record <span class="cov1" title="1">{
        return gt.getAllRecords(gt.sources)
}</span>

// GetAllRepositories returns all repository records.
func (gt *GedcomTree) GetAllRepositories() map[string]Record <span class="cov1" title="1">{
        return gt.getAllRecords(gt.repositories)
}</span>

// GetAllSubmitters returns all submitter records.
func (gt *GedcomTree) GetAllSubmitters() map[string]Record <span class="cov1" title="1">{
        return gt.getAllRecords(gt.submitters)
}</span>

// GetAllMultimedia returns all multimedia records.
func (gt *GedcomTree) GetAllMultimedia() map[string]Record <span class="cov1" title="1">{
        return gt.getAllRecords(gt.multimedia)
}</span>

// GetRecordByXref returns any record by its xref ID.
func (gt *GedcomTree) GetRecordByXref(xrefID string) Record <span class="cov4" title="3">{
        gt.mu.RLock()
        defer gt.mu.RUnlock()
        return gt.xrefIndex[xrefID]
}</span>

// GetRecordByUUID returns any record by its system-generated UUID.
func (gt *GedcomTree) GetRecordByUUID(uuid string) Record <span class="cov4" title="3">{
        gt.mu.RLock()
        defer gt.mu.RUnlock()
        return gt.uuidIndex[uuid]
}</span>

// SetEncoding sets the file encoding.
func (gt *GedcomTree) SetEncoding(encoding string) <span class="cov3" title="2">{
        gt.mu.Lock()
        defer gt.mu.Unlock()
        gt.encoding = encoding
}</span>

// GetEncoding returns the file encoding.
func (gt *GedcomTree) GetEncoding() string <span class="cov4" title="3">{
        gt.mu.RLock()
        defer gt.mu.RUnlock()
        return gt.encoding
}</span>

// SetVersion sets the GEDCOM version.
func (gt *GedcomTree) SetVersion(version string) <span class="cov3" title="2">{
        gt.mu.Lock()
        defer gt.mu.Unlock()
        gt.version = version
}</span>

// GetVersion returns the GEDCOM version.
func (gt *GedcomTree) GetVersion() string <span class="cov4" title="3">{
        gt.mu.RLock()
        defer gt.mu.RUnlock()
        return gt.version
}</span>

// getOrBuildGraph returns the query graph, building it lazily if needed.
// This is used internally by relationship traversal methods.
// Returns interface{} to avoid import cycle - callers should type assert to *query.Graph
func (gt *GedcomTree) getOrBuildGraph() (interface{}, error) <span class="cov0" title="0">{
        gt.graphMu.RLock()
        if gt.queryGraph != nil </span><span class="cov0" title="0">{
                gt.graphMu.RUnlock()
                return gt.queryGraph, nil
        }</span>
        <span class="cov0" title="0">gt.graphMu.RUnlock()

        gt.graphMu.Lock()
        defer gt.graphMu.Unlock()

        // Double-check after acquiring write lock
        if gt.queryGraph != nil </span><span class="cov0" title="0">{
                return gt.queryGraph, nil
        }</span>

        // Build graph (import query locally to avoid cycle)
        // This is done in individual_record.go methods instead
        // Return nil here - methods will build it themselves
        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
